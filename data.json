[{"tag":"Bouncy Castle  release-1.8.1 - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Not Sure\n","childs":{"0":[[{"content":"Not Sure","plain":"Not Sure\n","plainChilds":"    - <https://github.com/bcgit/bc-csharp>\n    - Last repository change: 2019-09-09T17:19:15\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"Archive":{"plain":"- https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip\n","childs":{"0":[[{"content":"https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip","plain":"https://github.com/bcgit/bc-csharp/archive/release-1.8.1.zip\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.8.1\n","childs":{"0":[[{"content":"Release: 1.8.1","plain":"Release: 1.8.1\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Development Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"s2n - https://github.com/awslabs/s2n","descr":"s2n : an implementation of the TLS/SSL protocols","Description":{"plain":"s2n is a C99 implementation of the TLS/SSL protocols that is designed to be simple, small, fast, and with security as a priority. It is released and licensed under the Apache License 2.0.","childs":{"0":["s2n is a C99 implementation of the TLS/SSL protocols that is designed to be simple, small, fast, and with security as a priority. It is released and licensed under the Apache License 2.0."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/awslabs/s2n>\n    - Last repository change: 2019-10-15T17:52:28\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Apache-2.0\n","childs":{"0":[[{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C99\n","childs":{"0":[[{"content":"C99","plain":"C99\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 3528\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 3528","plain":"Stars: 3528","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n- Ruby\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"Ruby","plain":"Ruby","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"libtomcrypt - http://www.libtom.net","descr":"LibTomCrypt is a fairly comprehensive, modular and portable cryptographic toolkit that provides developers with a vast array of well known published block ciphers, one-way hash functions, chaining modes, pseudo-random number generators, public key cryptography and a plethora of other routines","Description":{"plain":"LibTomCrypt is a fairly comprehensive, modular and portable cryptographic toolkit that provides developers with a vast array of well known published block ciphers, one-way hash functions, chaining modes, pseudo-random number generators, public key cryptography and a plethora of other routines.","childs":{"0":["LibTomCrypt is a fairly comprehensive, modular and portable cryptographic toolkit that provides developers with a vast array of well known published block ciphers, one-way hash functions, chaining modes, pseudo-random number generators, public key cryptography and a plethora of other routines."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/libtom/libtomcrypt>\n    - Last repository change: 2019-10-13T12:05:13\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Public domain\n- WTFPL\n","childs":{"0":[[{"content":"Public domain","plain":"Public domain\n","plainChilds":"","childs":[]},{"content":"WTFPL","plain":"WTFPL\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Company: Libtom Projects\n- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 877\n","childs":{"0":[[{"content":"Company: Libtom Projects","plain":"Company: Libtom Projects\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 877","plain":"Stars: 877","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"libtomcrypt","childs":{"0":["libtomcrypt"]}},"CVE Product":{"plain":"libtomcrypt","childs":{"0":["libtomcrypt"]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n- Java\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"Java","plain":"Java","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Anubis","plain":"Anubis","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"KASUMI","plain":"KASUMI","plainChilds":"","childs":[]},{"content":"KHAZAD","plain":"KHAZAD","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"MULTI2","plain":"MULTI2","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Skipjack","plain":"Skipjack","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Rabbit","plain":"Rabbit","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"Sosemanuk","plain":"Sosemanuk","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ff9c20\">Score: 7.5</span>: A \"mathematical flaw\" in the implementation of the El Gamal signature algorithm for LibTomCrypt 1.0 to 1.0.2 allows attackers to generate valid signatures without having the private key. (<https://cve.circl.lu/cve/CVE-2005-1600>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ff9c20\">Score: 7.5</span>: A \"mathematical flaw\" in the implementation of the El Gamal signature algorithm for LibTomCrypt 1.0 to 1.0.2 allows attackers to generate valid signatures without having the private key. (<https://cve.circl.lu/cve/CVE-2005-1600>)","plain":"- <span style=\"color:#ff9c20\">Score: 7.5</span>: A \"mathematical flaw\" in the implementation of the El Gamal signature algorithm for LibTomCrypt 1.0 to 1.0.2 allows attackers to generate valid signatures without having the private key. (<https://cve.circl.lu/cve/CVE-2005-1600>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"wolfSSL - http://www.wolfssl.com/","descr":"wolfSSL (formerly CyaSSL) is a small, fast, portable implementation of TLS/SSL for embedded devices to the cloud.","Description":{"plain":"The wolfSSL embedded SSL library (formerly CyaSSL) is a lightweight SSL/TLS library written in ANSI C and targeted for embedded, RTOS, and resource-constrained environments - primarily because of its small size, speed, and feature set. It is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support. wolfSSL supports industry standards up to the current TLS 1.3 and DTLS 1.3 levels, is up to 20 times smaller than OpenSSL, and offers progressive ciphers such as ChaCha20, Curve25519, NTRU, and Blake2b. User benchmarking and feedback reports dramatically better performance when using wolfSSL over OpenSSL.\n\nwolfSSL is powered by the wolfCrypt library. A version of the wolfCrypt cryptography library has been FIPS 140-2 validated (Certificate #2425). For additional information, visit the wolfCrypt FIPS FAQ or contact fips@wolfssl.com","childs":{"0":["The wolfSSL embedded SSL library (formerly CyaSSL) is a lightweight SSL/TLS library written in ANSI C and targeted for embedded, RTOS, and resource-constrained environments - primarily because of its small size, speed, and feature set. It is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support. wolfSSL supports industry standards up to the current TLS 1.3 and DTLS 1.3 levels, is up to 20 times smaller than OpenSSL, and offers progressive ciphers such as ChaCha20, Curve25519, NTRU, and Blake2b. User benchmarking and feedback reports dramatically better performance when using wolfSSL over OpenSSL.","wolfSSL is powered by the wolfCrypt library. A version of the wolfCrypt cryptography library has been FIPS 140-2 validated (Certificate #2425). For additional information, visit the wolfCrypt FIPS FAQ or contact fips@wolfssl.com"]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/wolfSSL/wolfssl>\n    - Last repository change: 2019-10-15T18:18:01\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- GPL-2.0\n- Commercial\n","childs":{"0":[[{"content":"GPL-2.0","plain":"GPL-2.0\n","plainChilds":"","childs":[]},{"content":"Commercial","plain":"Commercial\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n- Java\n- C#\n- Python\n- PHP\n- Perl\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]},{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]},{"content":"Python","plain":"Python\n","plainChilds":"","childs":[]},{"content":"PHP","plain":"PHP\n","plainChilds":"","childs":[]},{"content":"Perl","plain":"Perl\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"wolfssl","childs":{"0":["wolfssl"]}},"CVE Product":{"plain":"wolfssl","childs":{"0":["wolfssl"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 717\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 717","plain":"Stars: 717","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n- C#\n- Objective-C\n- JavaScript\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"C#","plain":"C#","plainChilds":"","childs":[]},{"content":"Objective-C","plain":"Objective-C","plainChilds":"","childs":[]},{"content":"JavaScript","plain":"JavaScript","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"Rabbit","plain":"Rabbit","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Vernam","plain":"Vernam","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"NTRUEncrypt","plain":"NTRUEncrypt","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"RTCS","plain":"RTCS","plainChilds":"","childs":[]},{"content":"SCEP","plain":"SCEP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SCEP","plain":"SCEP","plainChilds":"","childs":[]},{"content":"SCP","plain":"SCP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#00e020\">Score: 1.2</span>: wolfSSL and wolfCrypt 4.0.0 and earlier (when configured without --enable-fpecc, --enable-sp, or --enable-sp-math) contain a timing side channel in ECDSA signature generation. This allows a local attacker, able to precisely measure the duration of signature operations, to infer information about the nonces used and potentially mount a lattice attack to recover the private key used. The issue occurs because ecc.c scalar multiplication might leak the bit length. (<https://cve.circl.lu/cve/CVE-2019-13628>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In wolfSSL through 4.1.0, there is a missing sanity check of memory accesses in parsing ASN.1 certificate data while handshaking. Specifically, there is a one-byte heap-based buffer over-read in CheckCertSignature_ex in wolfcrypt/src/asn.c. (<https://cve.circl.lu/cve/CVE-2019-16748>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.1.0 has a one-byte heap-based buffer over-read in DecodeCertExtensions in wolfcrypt/src/asn.c because reading the ASN_BOOLEAN byte is mishandled for a crafted DER certificate in GetLength_ex. (<https://cve.circl.lu/cve/CVE-2019-15651>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.0.0 has a Buffer Overflow in DoPreSharedKeys in tls13.c when a current identity size is greater than a client identity size. An attacker sends a crafted hello client packet over the network to a TLSv1.3 wolfSSL server. The length fields of the packet: record length, client hello length, total extensions length, PSK extension length, total identity length, and identity length contain their maximum value which is 2^16. The identity data field of the PSK extension of the packet contains the attack data, to be stored in the undefined memory (RAM) of the server. The size of the data is about 65 kB. Possibly the attacker can perform a remote code execution attack. (<https://cve.circl.lu/cve/CVE-2019-11873>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: examples/benchmark/tls_bench.c in a benchmark tool in wolfSSL through 3.15.7 has a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2019-6439>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that wolfssl before 3.15.7 is vulnerable to a new variant of the Bleichenbacher attack to perform downgrade attacks against TLS. This may lead to leakage of sensible data. (<https://cve.circl.lu/cve/CVE-2018-16870>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: wolfcrypt/src/ecc.c in wolfSSL before 3.15.1.patch allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12436>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: wolfSSL prior to version 3.12.2 provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable wolfSSL application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13099>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: CyaSSL does not check the key usage extension in leaf certificates, which allows remote attackers to spoof servers via a crafted server certificate not authorized for use in an SSL/TLS handshake. (<https://cve.circl.lu/cve/CVE-2014-2903>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A specially crafted x509 certificate can cause a single out of bounds byte overwrite in wolfSSL through 3.10.2 resulting in potential certificate validation vulnerabilities, denial of service and possible remote code execution. In order to trigger this vulnerability, the attacker needs to supply a malicious x509 certificate to either a server or a client application using this library. (<https://cve.circl.lu/cve/CVE-2017-2800>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: wolfSSL before 3.11.0 does not prevent wc_DhAgree from accepting a malformed DH key. (<https://cve.circl.lu/cve/CVE-2017-8855>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: wolfSSL before 3.10.2 has an out-of-bounds memory access with loading crafted DH parameters, aka a buffer overflow triggered by a malformed temporary DH file. (<https://cve.circl.lu/cve/CVE-2017-8854>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In versions of wolfSSL before 3.10.2 the function fp_mul_comba makes it easier to extract RSA key information for a malicious user who has access to view cache on a machine. (<https://cve.circl.lu/cve/CVE-2017-6076>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of AES Encryption and Decryption in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover AES keys by leveraging cache-bank timing differences. (<https://cve.circl.lu/cve/CVE-2016-7440>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of RSA in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7439>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of ECC in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7438>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: wolfSSL (formerly CyaSSL) before 3.6.8 does not properly handle faults associated with the Chinese Remainder Theorem (CRT) process when allowing ephemeral key exchange without low memory optimizations on a server, which makes it easier for remote attackers to obtain private RSA keys by capturing TLS handshakes, aka a Lenstra attack. (<https://cve.circl.lu/cve/CVE-2015-7744>)\n- <span style=\"color:#ffe000\">Score: 5</span>: wolfSSL (formerly CyaSSL) before 3.6.8 allows remote attackers to cause a denial of service (resource consumption or traffic amplification) via a crafted DTLS cookie in a ClientHello message. (<https://cve.circl.lu/cve/CVE-2015-6925>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#00e020\">Score: 1.2</span>: wolfSSL and wolfCrypt 4.0.0 and earlier (when configured without --enable-fpecc, --enable-sp, or --enable-sp-math) contain a timing side channel in ECDSA signature generation. This allows a local attacker, able to precisely measure the duration of signature operations, to infer information about the nonces used and potentially mount a lattice attack to recover the private key used. The issue occurs because ecc.c scalar multiplication might leak the bit length. (<https://cve.circl.lu/cve/CVE-2019-13628>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In wolfSSL through 4.1.0, there is a missing sanity check of memory accesses in parsing ASN.1 certificate data while handshaking. Specifically, there is a one-byte heap-based buffer over-read in CheckCertSignature_ex in wolfcrypt/src/asn.c. (<https://cve.circl.lu/cve/CVE-2019-16748>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.1.0 has a one-byte heap-based buffer over-read in DecodeCertExtensions in wolfcrypt/src/asn.c because reading the ASN_BOOLEAN byte is mishandled for a crafted DER certificate in GetLength_ex. (<https://cve.circl.lu/cve/CVE-2019-15651>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.0.0 has a Buffer Overflow in DoPreSharedKeys in tls13.c when a current identity size is greater than a client identity size. An attacker sends a crafted hello client packet over the network to a TLSv1.3 wolfSSL server. The length fields of the packet: record length, client hello length, total extensions length, PSK extension length, total identity length, and identity length contain their maximum value which is 2^16. The identity data field of the PSK extension of the packet contains the attack data, to be stored in the undefined memory (RAM) of the server. The size of the data is about 65 kB. Possibly the attacker can perform a remote code execution attack. (<https://cve.circl.lu/cve/CVE-2019-11873>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: examples/benchmark/tls_bench.c in a benchmark tool in wolfSSL through 3.15.7 has a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2019-6439>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that wolfssl before 3.15.7 is vulnerable to a new variant of the Bleichenbacher attack to perform downgrade attacks against TLS. This may lead to leakage of sensible data. (<https://cve.circl.lu/cve/CVE-2018-16870>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: wolfcrypt/src/ecc.c in wolfSSL before 3.15.1.patch allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12436>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: wolfSSL prior to version 3.12.2 provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable wolfSSL application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13099>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: CyaSSL does not check the key usage extension in leaf certificates, which allows remote attackers to spoof servers via a crafted server certificate not authorized for use in an SSL/TLS handshake. (<https://cve.circl.lu/cve/CVE-2014-2903>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A specially crafted x509 certificate can cause a single out of bounds byte overwrite in wolfSSL through 3.10.2 resulting in potential certificate validation vulnerabilities, denial of service and possible remote code execution. In order to trigger this vulnerability, the attacker needs to supply a malicious x509 certificate to either a server or a client application using this library. (<https://cve.circl.lu/cve/CVE-2017-2800>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: wolfSSL before 3.11.0 does not prevent wc_DhAgree from accepting a malformed DH key. (<https://cve.circl.lu/cve/CVE-2017-8855>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: wolfSSL before 3.10.2 has an out-of-bounds memory access with loading crafted DH parameters, aka a buffer overflow triggered by a malformed temporary DH file. (<https://cve.circl.lu/cve/CVE-2017-8854>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In versions of wolfSSL before 3.10.2 the function fp_mul_comba makes it easier to extract RSA key information for a malicious user who has access to view cache on a machine. (<https://cve.circl.lu/cve/CVE-2017-6076>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of AES Encryption and Decryption in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover AES keys by leveraging cache-bank timing differences. (<https://cve.circl.lu/cve/CVE-2016-7440>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of RSA in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7439>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of ECC in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7438>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: wolfSSL (formerly CyaSSL) before 3.6.8 does not properly handle faults associated with the Chinese Remainder Theorem (CRT) process when allowing ephemeral key exchange without low memory optimizations on a server, which makes it easier for remote attackers to obtain private RSA keys by capturing TLS handshakes, aka a Lenstra attack. (<https://cve.circl.lu/cve/CVE-2015-7744>)\n- <span style=\"color:#ffe000\">Score: 5</span>: wolfSSL (formerly CyaSSL) before 3.6.8 allows remote attackers to cause a denial of service (resource consumption or traffic amplification) via a crafted DTLS cookie in a ClientHello message. (<https://cve.circl.lu/cve/CVE-2015-6925>)","plain":"- <span style=\"color:#00e020\">Score: 1.2</span>: wolfSSL and wolfCrypt 4.0.0 and earlier (when configured without --enable-fpecc, --enable-sp, or --enable-sp-math) contain a timing side channel in ECDSA signature generation. This allows a local attacker, able to precisely measure the duration of signature operations, to infer information about the nonces used and potentially mount a lattice attack to recover the private key used. The issue occurs because ecc.c scalar multiplication might leak the bit length. (<https://cve.circl.lu/cve/CVE-2019-13628>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In wolfSSL through 4.1.0, there is a missing sanity check of memory accesses in parsing ASN.1 certificate data while handshaking. Specifically, there is a one-byte heap-based buffer over-read in CheckCertSignature_ex in wolfcrypt/src/asn.c. (<https://cve.circl.lu/cve/CVE-2019-16748>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.1.0 has a one-byte heap-based buffer over-read in DecodeCertExtensions in wolfcrypt/src/asn.c because reading the ASN_BOOLEAN byte is mishandled for a crafted DER certificate in GetLength_ex. (<https://cve.circl.lu/cve/CVE-2019-15651>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: wolfSSL 4.0.0 has a Buffer Overflow in DoPreSharedKeys in tls13.c when a current identity size is greater than a client identity size. An attacker sends a crafted hello client packet over the network to a TLSv1.3 wolfSSL server. The length fields of the packet: record length, client hello length, total extensions length, PSK extension length, total identity length, and identity length contain their maximum value which is 2^16. The identity data field of the PSK extension of the packet contains the attack data, to be stored in the undefined memory (RAM) of the server. The size of the data is about 65 kB. Possibly the attacker can perform a remote code execution attack. (<https://cve.circl.lu/cve/CVE-2019-11873>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: examples/benchmark/tls_bench.c in a benchmark tool in wolfSSL through 3.15.7 has a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2019-6439>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that wolfssl before 3.15.7 is vulnerable to a new variant of the Bleichenbacher attack to perform downgrade attacks against TLS. This may lead to leakage of sensible data. (<https://cve.circl.lu/cve/CVE-2018-16870>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: wolfcrypt/src/ecc.c in wolfSSL before 3.15.1.patch allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12436>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: wolfSSL prior to version 3.12.2 provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable wolfSSL application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13099>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: CyaSSL does not check the key usage extension in leaf certificates, which allows remote attackers to spoof servers via a crafted server certificate not authorized for use in an SSL/TLS handshake. (<https://cve.circl.lu/cve/CVE-2014-2903>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A specially crafted x509 certificate can cause a single out of bounds byte overwrite in wolfSSL through 3.10.2 resulting in potential certificate validation vulnerabilities, denial of service and possible remote code execution. In order to trigger this vulnerability, the attacker needs to supply a malicious x509 certificate to either a server or a client application using this library. (<https://cve.circl.lu/cve/CVE-2017-2800>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: wolfSSL before 3.11.0 does not prevent wc_DhAgree from accepting a malformed DH key. (<https://cve.circl.lu/cve/CVE-2017-8855>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: wolfSSL before 3.10.2 has an out-of-bounds memory access with loading crafted DH parameters, aka a buffer overflow triggered by a malformed temporary DH file. (<https://cve.circl.lu/cve/CVE-2017-8854>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In versions of wolfSSL before 3.10.2 the function fp_mul_comba makes it easier to extract RSA key information for a malicious user who has access to view cache on a machine. (<https://cve.circl.lu/cve/CVE-2017-6076>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of AES Encryption and Decryption in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover AES keys by leveraging cache-bank timing differences. (<https://cve.circl.lu/cve/CVE-2016-7440>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of RSA in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7439>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: The C software implementation of ECC in wolfSSL (formerly CyaSSL) before 3.9.10 makes it easier for local users to discover RSA keys by leveraging cache-bank hit differences. (<https://cve.circl.lu/cve/CVE-2016-7438>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: wolfSSL (formerly CyaSSL) before 3.6.8 does not properly handle faults associated with the Chinese Remainder Theorem (CRT) process when allowing ephemeral key exchange without low memory optimizations on a server, which makes it easier for remote attackers to obtain private RSA keys by capturing TLS handshakes, aka a Lenstra attack. (<https://cve.circl.lu/cve/CVE-2015-7744>)\n- <span style=\"color:#ffe000\">Score: 5</span>: wolfSSL (formerly CyaSSL) before 3.6.8 allows remote attackers to cause a denial of service (resource consumption or traffic amplification) via a crafted DTLS cookie in a ClientHello message. (<https://cve.circl.lu/cve/CVE-2015-6925>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Botan - https://botan.randombit.net/","descr":"Botan is a BSD-licensed cryptographic library written in C++. It provides a wide variety of cryptographic algorithms, formats, and protocols, e.g. SSL and TLS. It is used in the Monotone distributed revision control program, the OpenDNSSEC system, and ISC's Kea DHCP server among other projects.","License":{"plain":"- BSD-2-Clause\n","childs":{"0":[[{"content":"BSD-2-Clause","plain":"BSD-2-Clause\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available.","childs":{"0":["Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/randombit/botan>\n    - Last repository change: 2019-10-16T16:38:00\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"Interface Languages":{"plain":"- C++11\n","childs":{"0":[[{"content":"C++11","plain":"C++11\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"botan_project","childs":{"0":["botan_project"]}},"CVE Product":{"plain":"botan","childs":{"0":["botan"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 1249\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 1249","plain":"Stars: 1249","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C++\n- Python\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"CAST-256","plain":"CAST-256","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"KASUMI","plain":"KASUMI","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MISTY1","plain":"MISTY1","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SHACAL","plain":"SHACAL","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Streebog","plain":"Streebog","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"Identrus","plain":"Identrus","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"MSE","plain":"MSE","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle  r1rv59 - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/bcgit/bc-java>\n    - Last repository change: 2019-10-07T11:03:08\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"Archive":{"plain":"- https://github.com/bcgit/bc-java/archive/r1rv59.zip\n","childs":{"0":[[{"content":"https://github.com/bcgit/bc-java/archive/r1rv59.zip","plain":"https://github.com/bcgit/bc-java/archive/r1rv59.zip\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- Java\n","childs":{"0":[[{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.59\n- Release Date: 2017-12-18\n","childs":{"0":[[{"content":"Release: 1.59","plain":"Release: 1.59\n","plainChilds":"","childs":[]},{"content":"Release Date: 2017-12-18","plain":"Release Date: 2017-12-18\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Development Languages":{"plain":"- Java\n","childs":{"0":[[{"content":"Java","plain":"Java","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"ARIA-128","plain":"ARIA-128","plainChilds":"","childs":[]},{"content":"ARIA-192","plain":"ARIA-192","plainChilds":"","childs":[]},{"content":"ARIA-256","plain":"ARIA-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"DFC","plain":"DFC","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Crypto1","plain":"Crypto1","plainChilds":"","childs":[]},{"content":"FISH","plain":"FISH","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]},{"content":"ZUC","plain":"ZUC","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DVCS","plain":"DVCS","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMC","plain":"CMC","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"I2P","plain":"I2P","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"ISAKMP","plain":"ISAKMP","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"KMIP","plain":"KMIP","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SCVP","plain":"SCVP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"WPS","plain":"WPS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"RHash - https://sf.net/p/rhash/","descr":"Great utility for computing hash sums","Description":{"plain":"RHash is a console utility for calculation  and verification of magnet links\nand a wide range of hash sums like  CRC32,  MD4, MD5,  SHA1, SHA256, SHA512,\nSHA3,   AICH,  ED2K,  Tiger,  DC++ TTH,  BitTorrent BTIH,   GOST R 34.11-94,\nRIPEMD-160, HAS-160, EDON-R, Whirlpool and Snefru.","childs":{"0":["RHash is a console utility for calculation and verification of magnet links and a wide range of hash sums like CRC32, MD4, MD5, SHA1, SHA256, SHA512, SHA3, AICH, ED2K, Tiger, DC++ TTH, BitTorrent BTIH, GOST R 34.11-94, RIPEMD-160, HAS-160, EDON-R, Whirlpool and Snefru."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/rhash/RHash>\n    - Last repository change: 2019-10-15T23:45:07\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- MIT\n- BSD\n- GPL\n- Commercial License\n- Freeware License\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]},{"content":"BSD","plain":"BSD\n","plainChilds":"","childs":[]},{"content":"GPL","plain":"GPL\n","plainChilds":"","childs":[]},{"content":"Commercial License","plain":"Commercial License\n","plainChilds":"","childs":[]},{"content":"Freeware License","plain":"Freeware License\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 254\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 254","plain":"Stars: 254","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Java\n- C#\n- Ruby\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Java","plain":"Java","plainChilds":"","childs":[]},{"content":"C#","plain":"C#","plainChilds":"","childs":[]},{"content":"Ruby","plain":"Ruby","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"Snefru","plain":"Snefru","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"wolfCrypt - http://www.example.com","descr":"wolfCrypt acts as a back-end crypto implementation for several popular software packages and libraries, including MIT Kerberos","Description":{"plain":"The wolfCrypt cryptography engine is a lightweight crypto library written in ANSI C and targeted for embedded, RTOS, and resource-constrained environments - primarily because of its small size, speed, and feature set.  It is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support.  wolfCrypt supports the most popular algorithms and ciphers as well as progressive ones such as HC-128, RABBIT, and NTRU.  wolfCrypt is stable, production-ready, and backed by our excellent team of security experts.  It is used in millions of application and devices worldwide.","childs":{"0":["The wolfCrypt cryptography engine is a lightweight crypto library written in ANSI C and targeted for embedded, RTOS, and resource-constrained environments - primarily because of its small size, speed, and feature set. It is commonly used in standard operating environments as well because of its royalty-free pricing and excellent cross platform support. wolfCrypt supports the most popular algorithms and ciphers as well as progressive ones such as HC-128, RABBIT, and NTRU. wolfCrypt is stable, production-ready, and backed by our excellent team of security experts. It is used in millions of application and devices worldwide."]}},"Repository":{"plain":"- https://github.com/wolfSSL/wolfssl/tree/master/wolfcrypt\n","childs":{"0":[[{"content":"https://github.com/wolfSSL/wolfssl/tree/master/wolfcrypt","plain":"https://github.com/wolfSSL/wolfssl/tree/master/wolfcrypt\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- GPL 2.0\n","childs":{"0":[[{"content":"GPL 2.0","plain":"GPL 2.0\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle 1.0.0 - http://bouncycastle.org/","descr":"Bouncy Castle C# Fips without repository and link to archive.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Repository specified","plain":"No Repository specified","plainChilds":"","childs":[]}]]}},"Description":{"plain":"This library has no repository specified.","childs":{"0":["This library has no repository specified."]}},"Interface Languages":{"plain":"- Java FIPS\n","childs":{"0":[[{"content":"Java FIPS","plain":"Java FIPS\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n- Java\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.0.0\n","childs":{"0":[[{"content":"Release: 1.0.0","plain":"Release: 1.0.0\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"HElib - http://shaih.github.io/HElib/","descr":"An Implementation of homomorphic encryption","Description":{"plain":"HElib is a software library that implements homomorphic encryption (HE). Currently available is an implementation of the Brakerski-Gentry-Vaikuntanathan (BGV) scheme, along with many optimizations to make homomorphic evaluation runs faster, focusing mostly on effective use of the Smart-Vercauteren ciphertext packing techniques and the Gentry-Halevi-Smart optimizations. See this report for a description of a few of the algorithms using in this library. Starting December 2014, the library also includes bootstrapping.","childs":{"0":["HElib is a software library that implements homomorphic encryption (HE). Currently available is an implementation of the Brakerski-Gentry-Vaikuntanathan (BGV) scheme, along with many optimizations to make homomorphic evaluation runs faster, focusing mostly on effective use of the Smart-Vercauteren ciphertext packing techniques and the Gentry-Halevi-Smart optimizations. See this report for a description of a few of the algorithms using in this library. Starting December 2014, the library also includes bootstrapping."]}},"Repository":{"plain":"- Not Sure\n","childs":{"0":[[{"content":"Not Sure","plain":"Not Sure\n","plainChilds":"    - <https://github.com/shaih/HElib>\n    - Last repository change: 2019-08-19T14:13:53\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Apache-2.0\n","childs":{"0":[[{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++\n","childs":{"0":[[{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 41\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 41","plain":"Stars: 41","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C++\n- C\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"C","plain":"C","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"cryptlib - http://www.cryptlib.com/","descr":"cryptlib is an open source cross-platform software security toolkit library. It is distributed under the Sleepycat License, a free software license compatible with the GNU General Public License.[3] Alternatively, cryptlib is available under a standard commercial license for those preferring to use it under commercial terms.","License":{"plain":"- Sleepycat\n","childs":{"0":[[{"content":"Sleepycat","plain":"Sleepycat\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Repository specified","plain":"No Repository specified","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The cryptlib Security Software Development Toolkit allows even inexperienced developers to easily add world-class security services to their applications by learning a single API. cryptlib manages all your SSL, SSH, TLS, S/MIME, PGP, OpenPGP, PKI, X.509, CMP, OCSP and SCEP security requirements, and more. cryptlib was designed by security experts, but not exclusively for security experts. It is highly efficient and has been rigorously tested across a wide range of operating systems and platforms over the last 18 years. The cryptlib software has been deployed and proven in many different sectors, and our clients state that it is the only security software development toolkit you’ll ever need.","childs":{"0":["The cryptlib Security Software Development Toolkit allows even inexperienced developers to easily add world-class security services to their applications by learning a single API. cryptlib manages all your SSL, SSH, TLS, S/MIME, PGP, OpenPGP, PKI, X.509, CMP, OCSP and SCEP security requirements, and more. cryptlib was designed by security experts, but not exclusively for security experts. It is highly efficient and has been rigorously tested across a wide range of operating systems and platforms over the last 18 years. The cryptlib software has been deployed and proven in many different sectors, and our clients state that it is the only security software development toolkit you’ll ever need."]}},"Development Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 3.4.3.1\n","childs":{"0":[[{"content":"Release: 3.4.3.1","plain":"Release: 3.4.3.1\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"","childs":{"0":[[{"content":"No Interface Languages specified","plain":"No Interface Languages specified","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"libsodium - https://libsodium.org","descr":"A portable, cross-compilable, installable, packageable, API-compatible version of NaCl","Description":{"plain":"Sodium is a new, easy-to-use software library for encryption, decryption, signatures, password hashing and more.\n\nIt is a portable, cross-compilable, installable, packageable fork of NaCl, with a compatible API, and an extended API to improve usability even further.\n\nIts goal is to provide all of the core operations needed to build higher-level cryptographic tools.\n\nSodium supports a variety of compilers and operating systems, including Windows (with MingW or Visual Studio, x86 and x64), iOS, Android, as well as Javascript and Webassembly.","childs":{"0":["Sodium is a new, easy-to-use software library for encryption, decryption, signatures, password hashing and more.","It is a portable, cross-compilable, installable, packageable fork of NaCl, with a compatible API, and an extended API to improve usability even further.","Its goal is to provide all of the core operations needed to build higher-level cryptographic tools.","Sodium supports a variety of compilers and operating systems, including Windows (with MingW or Visual Studio, x86 and x64), iOS, Android, as well as Javascript and Webassembly."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/jedisct1/libsodium>\n    - Last repository change: 2019-10-12T06:54:58\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- ISC License\n","childs":{"0":[[{"content":"ISC License","plain":"ISC License\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- PHP >= 7.2\n- HHVM >=3.20\n- Citrine\n- Zion\n","childs":{"0":[[{"content":"PHP >= 7.2","plain":"PHP >= 7.2\n","plainChilds":"","childs":[]},{"content":"HHVM >=3.20","plain":"HHVM >=3.20\n","plainChilds":"","childs":[]},{"content":"Citrine","plain":"Citrine\n","plainChilds":"","childs":[]},{"content":"Zion","plain":"Zion\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 7648\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 7648","plain":"Stars: 7648","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Nettle - http://lysator.liu.se/~nisse/nettle/","descr":"Nettle is a low-level cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.","Description":{"plain":" Nettle is a cryptographic library that is designed to fit easily in more\n  or less any context: In crypto toolkits for object-oriented languages\n  (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in\n  kernel space. In most contexts, you need more than the basic\n  cryptographic algorithms, you also need some way to keep track of available\n  algorithms, their properties and variants. You often have some algorithm\n  selection process, often dictated by a protocol you want to implement.","childs":{"0":["Nettle is a cryptographic library that is designed to fit easily in more  or less any context: In crypto toolkits for object-oriented languages  (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in  kernel space. In most contexts, you need more than the basic  cryptographic algorithms, you also need some way to keep track of available  algorithms, their properties and variants. You often have some algorithm  selection process, often dictated by a protocol you want to implement."]}},"Repository":{"plain":"- https://git.lysator.liu.se/nettle/nettle\n","childs":{"0":[[{"content":"https://git.lysator.liu.se/nettle/nettle","plain":"https://git.lysator.liu.se/nettle/nettle\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- GNU LGPLv3\n- GNU GPLv2\n- GNU GPLv3\n","childs":{"0":[[{"content":"GNU LGPLv3","plain":"GNU LGPLv3\n","plainChilds":"","childs":[]},{"content":"GNU GPLv2","plain":"GNU GPLv2\n","plainChilds":"","childs":[]},{"content":"GNU GPLv3","plain":"GNU GPLv3\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Developer: Niels Möller\n- The information is applicable to the latest commit in the repository, not a specific release!\n","childs":{"0":[[{"content":"Developer: Niels Möller","plain":"Developer: Niels Möller\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++\n- Pyton\n- Pike\n- Perl\n- PostgreSQL\n- R6RS Scheme\n- Haskell\n- TCL\n","childs":{"0":[[{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]},{"content":"Pyton","plain":"Pyton\n","plainChilds":"","childs":[]},{"content":"Pike","plain":"Pike\n","plainChilds":"","childs":[]},{"content":"Perl","plain":"Perl\n","plainChilds":"","childs":[]},{"content":"PostgreSQL","plain":"PostgreSQL\n","plainChilds":"","childs":[]},{"content":"R6RS Scheme","plain":"R6RS Scheme\n","plainChilds":"","childs":[]},{"content":"Haskell","plain":"Haskell\n","plainChilds":"","childs":[]},{"content":"TCL","plain":"TCL\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"nettle_project","childs":{"0":["nettle_project"]}},"CVE Product":{"plain":"nettle","childs":{"0":["nettle"]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Pike","plain":"Pike","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]},{"content":"UMAC","plain":"UMAC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#d1ff00\">Score: 3.3</span>: A Bleichenbacher type side-channel based padding oracle attack was found in the way nettle handles endian conversion of RSA decrypted PKCS#1 v1.5 data. An attacker who is able to run a process on the same physical core as the victim process, could use this flaw extract plaintext or in some cases downgrade any TLS connections to a vulnerable server. (<https://cve.circl.lu/cve/CVE-2018-16869>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The RSA and DSA decryption code in Nettle makes it easier for attackers to discover private keys via a cache side channel attack. (<https://cve.circl.lu/cve/CVE-2016-6489>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modp function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8805. (<https://cve.circl.lu/cve/CVE-2015-8803>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modq function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8803. (<https://cve.circl.lu/cve/CVE-2015-8805>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: x86_64/ecc-384-modp.asm in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-384 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2015-8804>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#d1ff00\">Score: 3.3</span>: A Bleichenbacher type side-channel based padding oracle attack was found in the way nettle handles endian conversion of RSA decrypted PKCS#1 v1.5 data. An attacker who is able to run a process on the same physical core as the victim process, could use this flaw extract plaintext or in some cases downgrade any TLS connections to a vulnerable server. (<https://cve.circl.lu/cve/CVE-2018-16869>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The RSA and DSA decryption code in Nettle makes it easier for attackers to discover private keys via a cache side channel attack. (<https://cve.circl.lu/cve/CVE-2016-6489>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modp function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8805. (<https://cve.circl.lu/cve/CVE-2015-8803>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modq function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8803. (<https://cve.circl.lu/cve/CVE-2015-8805>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: x86_64/ecc-384-modp.asm in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-384 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2015-8804>)","plain":"- <span style=\"color:#d1ff00\">Score: 3.3</span>: A Bleichenbacher type side-channel based padding oracle attack was found in the way nettle handles endian conversion of RSA decrypted PKCS#1 v1.5 data. An attacker who is able to run a process on the same physical core as the victim process, could use this flaw extract plaintext or in some cases downgrade any TLS connections to a vulnerable server. (<https://cve.circl.lu/cve/CVE-2018-16869>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The RSA and DSA decryption code in Nettle makes it easier for attackers to discover private keys via a cache side channel attack. (<https://cve.circl.lu/cve/CVE-2016-6489>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modp function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8805. (<https://cve.circl.lu/cve/CVE-2015-8803>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The ecc_256_modq function in ecc-256.c in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-256 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors, a different vulnerability than CVE-2015-8803. (<https://cve.circl.lu/cve/CVE-2015-8805>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: x86_64/ecc-384-modp.asm in Nettle before 3.2 does not properly handle carry propagation and produces incorrect output in its implementation of the P-384 NIST elliptic curve, which allows attackers to have unspecified impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2015-8804>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"crypto - https://golang.org/pkg/crypto/","descr":"Package crypto collects common cryptographic constants.","Description":{"plain":"Package crypto collects common cryptographic constants.","childs":{"0":["Package crypto collects common cryptographic constants."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/golang/go>\n    - Last repository change: 2019-10-16T02:58:40\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- 3-Clause BSD\n","childs":{"0":[[{"content":"3-Clause BSD","plain":"3-Clause BSD\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- Go\n","childs":{"0":[[{"content":"Go","plain":"Go\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"golang","childs":{"0":["golang"]}},"CVE Product":{"plain":"go","childs":{"0":["go"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 64625\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 64625","plain":"Stars: 64625","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- Go\n- C\n- C++\n- JavaScript\n- Objective-C\n- Python\n","childs":{"0":[[{"content":"Go","plain":"Go","plainChilds":"","childs":[]},{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"JavaScript","plain":"JavaScript","plainChilds":"","childs":[]},{"content":"Objective-C","plain":"Objective-C","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"DFC","plain":"DFC","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MAGENTA","plain":"MAGENTA","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"NLS","plain":"NLS","plainChilds":"","childs":[]},{"content":"Panama","plain":"Panama","plainChilds":"","childs":[]},{"content":"Rabbit","plain":"Rabbit","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Scream","plain":"Scream","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]},{"content":"Solitaire","plain":"Solitaire","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]},{"content":"Vernam","plain":"Vernam","plainChilds":"","childs":[]},{"content":"WAKE","plain":"WAKE","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"DFF","plain":"DFF","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"RAC","plain":"RAC","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"TinyCA","plain":"TinyCA","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS1","plain":"AS1","plainChilds":"","childs":[]},{"content":"AS2","plain":"AS2","plainChilds":"","childs":[]},{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"ACME","plain":"ACME","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CGA","plain":"CGA","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"DPV","plain":"DPV","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"EKE","plain":"EKE","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PCT","plain":"PCT","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"PoSE","plain":"PoSE","plainChilds":"","childs":[]},{"content":"SCP","plain":"SCP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 5.0</span>: Go before 1.12.10 and 1.13.x before 1.13.1 allow HTTP Request Smuggling. (<https://cve.circl.lu/cve/CVE-2019-16276>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: net/url in Go before 1.11.13 and 1.12.x before 1.12.8 mishandles malformed hosts in URLs, leading to an authorization bypass in some applications. This is related to a Host field with a suffix appearing in neither Hostname() nor Port(), and is related to a non-numeric port number. For example, an attacker can compose a crafted javascript:// URL that results in a hostname of google.com. (<https://cve.circl.lu/cve/CVE-2019-14809>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go through 1.12.5 on Windows mishandles process creation with a nil environment in conjunction with a non-nil token, which allows attackers to obtain sensitive information or gain privileges. (<https://cve.circl.lu/cve/CVE-2019-11888>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An issue was discovered in net/http in Go 1.11.5. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the second argument to http.NewRequest with \r\n followed by an HTTP header or a Redis command. (<https://cve.circl.lu/cve/CVE-2019-9741>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Go through 1.12 on Windows misuses certain LoadLibrary functionality, leading to DLL injection. (<https://cve.circl.lu/cve/CVE-2019-9634>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Go before 1.10.8 and 1.11.x before 1.11.5 mishandles P-521 and P-384 elliptic curves, which allows attackers to cause a denial of service (CPU consumption) or possibly conduct ECDH private key recovery attacks. (<https://cve.circl.lu/cve/CVE-2019-6486>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The crypto/x509 package of Go before 1.10.6 and 1.11.x before 1.11.3 does not limit the amount of work performed for each chain verification, which might allow attackers to craft pathological inputs leading to a CPU denial of service. Go TLS servers accepting client certificates and TLS clients are affected. (<https://cve.circl.lu/cve/CVE-2018-16875>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to directory traversal when executed with the import path of a malicious Go package which contains curly braces (both '{' and '}' characters). Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). The attacker can cause an arbitrary filesystem write, which can lead to code execution. (<https://cve.circl.lu/cve/CVE-2018-16874>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to remote code execution when executed with the -u flag and the import path of a malicious Go package, or a package that imports it directly or indirectly. Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). Using custom domains, it's possible to arrange things so that a Git repository is cloned to a folder named \".git\" by using a vanity import path that ends with \"/.git\". If the Git repository root contains a \"HEAD\" file, a \"config\" file, an \"objects\" directory, a \"refs\" directory, with some work to ensure the proper ordering of operations, \"go get -u\" can be tricked into considering the parent directory as a repository root, and running Git commands on it. That will use the \"config\" file in the original Git repository root for its configuration, and if that config file contains malicious commands, they will execute on the system running \"go get -u\". (<https://cve.circl.lu/cve/CVE-2018-16873>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <math><template><mn><b></template>, leading to a \"panic: runtime error\" (index out of range) in (*insertionModeStack).pop in node.go, called from inHeadIM, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17848>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <svg><template><desc><t><svg></template>, leading to a \"panic: runtime error\" (index out of range) in (*nodeStack).pop in node.go, called from (*parser).clearActiveFormattingElements, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17847>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <table><math><select><mi><select></table>, leading to an infinite loop during an html.Parse call because inSelectIM and inSelectInTableIM do not comply with a specification. (<https://cve.circl.lu/cve/CVE-2018-17846>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <template><tBody><isindex/action=0>, leading to a \"panic: runtime error\" in inBodyIM in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17143>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <math><template><mo><template>, leading to a \"panic: runtime error\" in parseCurrentToken in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17142>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) before 2018-07-13 in Go mishandles \"in frameset\" insertion mode, leading to a \"panic: runtime error\" for html.Parse of <template><object>, <template><applet>, or <template><marquee>. This is related to HTMLTreeBuilder.cpp in WebKit. (<https://cve.circl.lu/cve/CVE-2018-17075>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: The \"go get\" implementation in Go 1.9.4, when the -insecure command-line option is used, does not validate the import path (get/vcs.go only checks for \"://\" anywhere in the string), which allows remote attackers to execute arbitrary OS commands via a crafted web site. (<https://cve.circl.lu/cve/CVE-2018-7187>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2 allow \"go get\" remote command execution during source code build, by leveraging the gcc or clang plugin feature, because -fplugin= and -plugin= arguments were not blocked. (<https://cve.circl.lu/cve/CVE-2018-6574>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request with two Content-length headers. (<https://cve.circl.lu/cve/CVE-2015-5740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/textproto/reader.go in Go before 1.4.3 does not properly parse HTTP header keys, which allows remote attackers to conduct HTTP request smuggling attacks via a space instead of a hyphen, as demonstrated by \"Content Length\" instead of \"Content-Length.\" (<https://cve.circl.lu/cve/CVE-2015-5739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An unintended cleartext issue exists in Go before 1.8.4 and 1.9.x before 1.9.1. RFC 4954 requires that, during SMTP, the PLAIN auth scheme must only be used on network connections secured with TLS. The original implementation of smtp.PlainAuth in Go 1.0 enforced this requirement, and it was documented to do so. In 2013, upstream issue #5184, this was changed so that the server may decide whether PLAIN is acceptable. The result is that if you set up a man-in-the-middle SMTP server that doesn't advertise STARTTLS and does advertise that PLAIN auth is OK, the smtp.PlainAuth implementation sends the username and password. (<https://cve.circl.lu/cve/CVE-2017-15042>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go before 1.8.4 and 1.9.x before 1.9.1 allows \"go get\" remote command execution. Using custom domains, it is possible to arrange things so that example.com/pkg1 points to a Subversion repository but example.com/pkg1/pkg2 points to a Git repository. If the Subversion repository includes a Git checkout in its pkg2 directory and some other work is done to ensure the proper ordering of operations, \"go get\" can be tricked into reusing this Git checkout for the fetch of code from pkg2. If the Subversion repository's Git checkout has malicious commands in .git/hooks/, they will execute on the system running \"go get.\" (<https://cve.circl.lu/cve/CVE-2017-15041>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The net/http package's Request.ParseMultipartForm method starts writing to temporary files once the request body size surpasses the given \"maxMemory\" limit. It was possible for an attacker to generate a multipart request crafted such that the server ran out of file descriptors. (<https://cve.circl.lu/cve/CVE-2017-1000098>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: On Darwin, user's trust preferences for root certificates were not honored. If the user had a root certificate loaded in their Keychain that was explicitly not trusted, a Go program would still verify a connection using that root certificate. (<https://cve.circl.lu/cve/CVE-2017-1000097>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: A bug in the standard library ScalarMult implementation of curve P-256 for amd64 architectures in Go before 1.7.6 and 1.8.x before 1.8.2 causes incorrect results to be generated for specific input points. An adaptive attack can be mounted to progressively extract the scalar input to ScalarMult by submitting crafted points and observing failures to the derive correct output. This leads to a full key recovery attack against static ECDH, as used in popular JWT libraries. (<https://cve.circl.lu/cve/CVE-2017-8932>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: The net/http package in Go through 1.6 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. (<https://cve.circl.lu/cve/CVE-2016-5386>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Int.Exp Montgomery code in the math/big library in Go 1.5.x before 1.5.3 mishandles carry propagation and produces incorrect output, which makes it easier for attackers to obtain private RSA keys via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-8618>)\n- <span style=\"color:#ff9c20\">Score: 7.2</span>: Untrusted search path vulnerability in Go before 1.5.4 and 1.6.x before 1.6.1 on Windows allows local users to gain privileges via a Trojan horse DLL in the current working directory, related to use of the LoadLibrary function. (<https://cve.circl.lu/cve/CVE-2016-3958>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Verify function in crypto/dsa/dsa.go in Go before 1.5.4 and 1.6.x before 1.6.1 does not properly check parameters passed to the big integer library, which might allow remote attackers to cause a denial of service (infinite loop) via a crafted public key to a program that uses HTTPS client certificates or SSH server libraries. (<https://cve.circl.lu/cve/CVE-2016-3959>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: crpyto/tls in Go 1.1 before 1.3.2, when SessionTicketsDisabled is enabled, allows man-in-the-middle attackers to spoof clients via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2014-7189>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 5.0</span>: Go before 1.12.10 and 1.13.x before 1.13.1 allow HTTP Request Smuggling. (<https://cve.circl.lu/cve/CVE-2019-16276>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: net/url in Go before 1.11.13 and 1.12.x before 1.12.8 mishandles malformed hosts in URLs, leading to an authorization bypass in some applications. This is related to a Host field with a suffix appearing in neither Hostname() nor Port(), and is related to a non-numeric port number. For example, an attacker can compose a crafted javascript:// URL that results in a hostname of google.com. (<https://cve.circl.lu/cve/CVE-2019-14809>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go through 1.12.5 on Windows mishandles process creation with a nil environment in conjunction with a non-nil token, which allows attackers to obtain sensitive information or gain privileges. (<https://cve.circl.lu/cve/CVE-2019-11888>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An issue was discovered in net/http in Go 1.11.5. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the second argument to http.NewRequest with \r\n followed by an HTTP header or a Redis command. (<https://cve.circl.lu/cve/CVE-2019-9741>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Go through 1.12 on Windows misuses certain LoadLibrary functionality, leading to DLL injection. (<https://cve.circl.lu/cve/CVE-2019-9634>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Go before 1.10.8 and 1.11.x before 1.11.5 mishandles P-521 and P-384 elliptic curves, which allows attackers to cause a denial of service (CPU consumption) or possibly conduct ECDH private key recovery attacks. (<https://cve.circl.lu/cve/CVE-2019-6486>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The crypto/x509 package of Go before 1.10.6 and 1.11.x before 1.11.3 does not limit the amount of work performed for each chain verification, which might allow attackers to craft pathological inputs leading to a CPU denial of service. Go TLS servers accepting client certificates and TLS clients are affected. (<https://cve.circl.lu/cve/CVE-2018-16875>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to directory traversal when executed with the import path of a malicious Go package which contains curly braces (both '{' and '}' characters). Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). The attacker can cause an arbitrary filesystem write, which can lead to code execution. (<https://cve.circl.lu/cve/CVE-2018-16874>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to remote code execution when executed with the -u flag and the import path of a malicious Go package, or a package that imports it directly or indirectly. Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). Using custom domains, it's possible to arrange things so that a Git repository is cloned to a folder named \".git\" by using a vanity import path that ends with \"/.git\". If the Git repository root contains a \"HEAD\" file, a \"config\" file, an \"objects\" directory, a \"refs\" directory, with some work to ensure the proper ordering of operations, \"go get -u\" can be tricked into considering the parent directory as a repository root, and running Git commands on it. That will use the \"config\" file in the original Git repository root for its configuration, and if that config file contains malicious commands, they will execute on the system running \"go get -u\". (<https://cve.circl.lu/cve/CVE-2018-16873>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <math><template><mn><b></template>, leading to a \"panic: runtime error\" (index out of range) in (*insertionModeStack).pop in node.go, called from inHeadIM, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17848>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <svg><template><desc><t><svg></template>, leading to a \"panic: runtime error\" (index out of range) in (*nodeStack).pop in node.go, called from (*parser).clearActiveFormattingElements, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17847>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <table><math><select><mi><select></table>, leading to an infinite loop during an html.Parse call because inSelectIM and inSelectInTableIM do not comply with a specification. (<https://cve.circl.lu/cve/CVE-2018-17846>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <template><tBody><isindex/action=0>, leading to a \"panic: runtime error\" in inBodyIM in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17143>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <math><template><mo><template>, leading to a \"panic: runtime error\" in parseCurrentToken in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17142>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) before 2018-07-13 in Go mishandles \"in frameset\" insertion mode, leading to a \"panic: runtime error\" for html.Parse of <template><object>, <template><applet>, or <template><marquee>. This is related to HTMLTreeBuilder.cpp in WebKit. (<https://cve.circl.lu/cve/CVE-2018-17075>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: The \"go get\" implementation in Go 1.9.4, when the -insecure command-line option is used, does not validate the import path (get/vcs.go only checks for \"://\" anywhere in the string), which allows remote attackers to execute arbitrary OS commands via a crafted web site. (<https://cve.circl.lu/cve/CVE-2018-7187>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2 allow \"go get\" remote command execution during source code build, by leveraging the gcc or clang plugin feature, because -fplugin= and -plugin= arguments were not blocked. (<https://cve.circl.lu/cve/CVE-2018-6574>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request with two Content-length headers. (<https://cve.circl.lu/cve/CVE-2015-5740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/textproto/reader.go in Go before 1.4.3 does not properly parse HTTP header keys, which allows remote attackers to conduct HTTP request smuggling attacks via a space instead of a hyphen, as demonstrated by \"Content Length\" instead of \"Content-Length.\" (<https://cve.circl.lu/cve/CVE-2015-5739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An unintended cleartext issue exists in Go before 1.8.4 and 1.9.x before 1.9.1. RFC 4954 requires that, during SMTP, the PLAIN auth scheme must only be used on network connections secured with TLS. The original implementation of smtp.PlainAuth in Go 1.0 enforced this requirement, and it was documented to do so. In 2013, upstream issue #5184, this was changed so that the server may decide whether PLAIN is acceptable. The result is that if you set up a man-in-the-middle SMTP server that doesn't advertise STARTTLS and does advertise that PLAIN auth is OK, the smtp.PlainAuth implementation sends the username and password. (<https://cve.circl.lu/cve/CVE-2017-15042>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go before 1.8.4 and 1.9.x before 1.9.1 allows \"go get\" remote command execution. Using custom domains, it is possible to arrange things so that example.com/pkg1 points to a Subversion repository but example.com/pkg1/pkg2 points to a Git repository. If the Subversion repository includes a Git checkout in its pkg2 directory and some other work is done to ensure the proper ordering of operations, \"go get\" can be tricked into reusing this Git checkout for the fetch of code from pkg2. If the Subversion repository's Git checkout has malicious commands in .git/hooks/, they will execute on the system running \"go get.\" (<https://cve.circl.lu/cve/CVE-2017-15041>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The net/http package's Request.ParseMultipartForm method starts writing to temporary files once the request body size surpasses the given \"maxMemory\" limit. It was possible for an attacker to generate a multipart request crafted such that the server ran out of file descriptors. (<https://cve.circl.lu/cve/CVE-2017-1000098>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: On Darwin, user's trust preferences for root certificates were not honored. If the user had a root certificate loaded in their Keychain that was explicitly not trusted, a Go program would still verify a connection using that root certificate. (<https://cve.circl.lu/cve/CVE-2017-1000097>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: A bug in the standard library ScalarMult implementation of curve P-256 for amd64 architectures in Go before 1.7.6 and 1.8.x before 1.8.2 causes incorrect results to be generated for specific input points. An adaptive attack can be mounted to progressively extract the scalar input to ScalarMult by submitting crafted points and observing failures to the derive correct output. This leads to a full key recovery attack against static ECDH, as used in popular JWT libraries. (<https://cve.circl.lu/cve/CVE-2017-8932>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: The net/http package in Go through 1.6 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. (<https://cve.circl.lu/cve/CVE-2016-5386>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Int.Exp Montgomery code in the math/big library in Go 1.5.x before 1.5.3 mishandles carry propagation and produces incorrect output, which makes it easier for attackers to obtain private RSA keys via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-8618>)\n- <span style=\"color:#ff9c20\">Score: 7.2</span>: Untrusted search path vulnerability in Go before 1.5.4 and 1.6.x before 1.6.1 on Windows allows local users to gain privileges via a Trojan horse DLL in the current working directory, related to use of the LoadLibrary function. (<https://cve.circl.lu/cve/CVE-2016-3958>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Verify function in crypto/dsa/dsa.go in Go before 1.5.4 and 1.6.x before 1.6.1 does not properly check parameters passed to the big integer library, which might allow remote attackers to cause a denial of service (infinite loop) via a crafted public key to a program that uses HTTPS client certificates or SSH server libraries. (<https://cve.circl.lu/cve/CVE-2016-3959>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: crpyto/tls in Go 1.1 before 1.3.2, when SessionTicketsDisabled is enabled, allows man-in-the-middle attackers to spoof clients via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2014-7189>)","plain":"- <span style=\"color:#ffe000\">Score: 5.0</span>: Go before 1.12.10 and 1.13.x before 1.13.1 allow HTTP Request Smuggling. (<https://cve.circl.lu/cve/CVE-2019-16276>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: net/url in Go before 1.11.13 and 1.12.x before 1.12.8 mishandles malformed hosts in URLs, leading to an authorization bypass in some applications. This is related to a Host field with a suffix appearing in neither Hostname() nor Port(), and is related to a non-numeric port number. For example, an attacker can compose a crafted javascript:// URL that results in a hostname of google.com. (<https://cve.circl.lu/cve/CVE-2019-14809>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go through 1.12.5 on Windows mishandles process creation with a nil environment in conjunction with a non-nil token, which allows attackers to obtain sensitive information or gain privileges. (<https://cve.circl.lu/cve/CVE-2019-11888>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An issue was discovered in net/http in Go 1.11.5. CRLF injection is possible if the attacker controls a url parameter, as demonstrated by the second argument to http.NewRequest with \r\n followed by an HTTP header or a Redis command. (<https://cve.circl.lu/cve/CVE-2019-9741>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Go through 1.12 on Windows misuses certain LoadLibrary functionality, leading to DLL injection. (<https://cve.circl.lu/cve/CVE-2019-9634>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Go before 1.10.8 and 1.11.x before 1.11.5 mishandles P-521 and P-384 elliptic curves, which allows attackers to cause a denial of service (CPU consumption) or possibly conduct ECDH private key recovery attacks. (<https://cve.circl.lu/cve/CVE-2019-6486>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The crypto/x509 package of Go before 1.10.6 and 1.11.x before 1.11.3 does not limit the amount of work performed for each chain verification, which might allow attackers to craft pathological inputs leading to a CPU denial of service. Go TLS servers accepting client certificates and TLS clients are affected. (<https://cve.circl.lu/cve/CVE-2018-16875>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to directory traversal when executed with the import path of a malicious Go package which contains curly braces (both '{' and '}' characters). Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). The attacker can cause an arbitrary filesystem write, which can lead to code execution. (<https://cve.circl.lu/cve/CVE-2018-16874>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: In Go before 1.10.6 and 1.11.x before 1.11.3, the \"go get\" command is vulnerable to remote code execution when executed with the -u flag and the import path of a malicious Go package, or a package that imports it directly or indirectly. Specifically, it is only vulnerable in GOPATH mode, but not in module mode (the distinction is documented at https://golang.org/cmd/go/#hdr-Module_aware_go_get). Using custom domains, it's possible to arrange things so that a Git repository is cloned to a folder named \".git\" by using a vanity import path that ends with \"/.git\". If the Git repository root contains a \"HEAD\" file, a \"config\" file, an \"objects\" directory, a \"refs\" directory, with some work to ensure the proper ordering of operations, \"go get -u\" can be tricked into considering the parent directory as a repository root, and running Git commands on it. That will use the \"config\" file in the original Git repository root for its configuration, and if that config file contains malicious commands, they will execute on the system running \"go get -u\". (<https://cve.circl.lu/cve/CVE-2018-16873>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <math><template><mn><b></template>, leading to a \"panic: runtime error\" (index out of range) in (*insertionModeStack).pop in node.go, called from inHeadIM, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17848>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <svg><template><desc><t><svg></template>, leading to a \"panic: runtime error\" (index out of range) in (*nodeStack).pop in node.go, called from (*parser).clearActiveFormattingElements, during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17847>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-25 in Go mishandles <table><math><select><mi><select></table>, leading to an infinite loop during an html.Parse call because inSelectIM and inSelectInTableIM do not comply with a specification. (<https://cve.circl.lu/cve/CVE-2018-17846>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <template><tBody><isindex/action=0>, leading to a \"panic: runtime error\" in inBodyIM in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17143>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) through 2018-09-17 in Go mishandles <math><template><mo><template>, leading to a \"panic: runtime error\" in parseCurrentToken in parse.go during an html.Parse call. (<https://cve.circl.lu/cve/CVE-2018-17142>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The html package (aka x/net/html) before 2018-07-13 in Go mishandles \"in frameset\" insertion mode, leading to a \"panic: runtime error\" for html.Parse of <template><object>, <template><applet>, or <template><marquee>. This is related to HTMLTreeBuilder.cpp in WebKit. (<https://cve.circl.lu/cve/CVE-2018-17075>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: The \"go get\" implementation in Go 1.9.4, when the -insecure command-line option is used, does not validate the import path (get/vcs.go only checks for \"://\" anywhere in the string), which allows remote attackers to execute arbitrary OS commands via a crafted web site. (<https://cve.circl.lu/cve/CVE-2018-7187>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2 allow \"go get\" remote command execution during source code build, by leveraging the gcc or clang plugin feature, because -fplugin= and -plugin= arguments were not blocked. (<https://cve.circl.lu/cve/CVE-2018-6574>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/http/transfer.go in Go before 1.4.3 does not properly parse HTTP headers, which allows remote attackers to conduct HTTP request smuggling attacks via a request with two Content-length headers. (<https://cve.circl.lu/cve/CVE-2015-5740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The net/http library in net/textproto/reader.go in Go before 1.4.3 does not properly parse HTTP header keys, which allows remote attackers to conduct HTTP request smuggling attacks via a space instead of a hyphen, as demonstrated by \"Content Length\" instead of \"Content-Length.\" (<https://cve.circl.lu/cve/CVE-2015-5739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An unintended cleartext issue exists in Go before 1.8.4 and 1.9.x before 1.9.1. RFC 4954 requires that, during SMTP, the PLAIN auth scheme must only be used on network connections secured with TLS. The original implementation of smtp.PlainAuth in Go 1.0 enforced this requirement, and it was documented to do so. In 2013, upstream issue #5184, this was changed so that the server may decide whether PLAIN is acceptable. The result is that if you set up a man-in-the-middle SMTP server that doesn't advertise STARTTLS and does advertise that PLAIN auth is OK, the smtp.PlainAuth implementation sends the username and password. (<https://cve.circl.lu/cve/CVE-2017-15042>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Go before 1.8.4 and 1.9.x before 1.9.1 allows \"go get\" remote command execution. Using custom domains, it is possible to arrange things so that example.com/pkg1 points to a Subversion repository but example.com/pkg1/pkg2 points to a Git repository. If the Subversion repository includes a Git checkout in its pkg2 directory and some other work is done to ensure the proper ordering of operations, \"go get\" can be tricked into reusing this Git checkout for the fetch of code from pkg2. If the Subversion repository's Git checkout has malicious commands in .git/hooks/, they will execute on the system running \"go get.\" (<https://cve.circl.lu/cve/CVE-2017-15041>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The net/http package's Request.ParseMultipartForm method starts writing to temporary files once the request body size surpasses the given \"maxMemory\" limit. It was possible for an attacker to generate a multipart request crafted such that the server ran out of file descriptors. (<https://cve.circl.lu/cve/CVE-2017-1000098>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: On Darwin, user's trust preferences for root certificates were not honored. If the user had a root certificate loaded in their Keychain that was explicitly not trusted, a Go program would still verify a connection using that root certificate. (<https://cve.circl.lu/cve/CVE-2017-1000097>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: A bug in the standard library ScalarMult implementation of curve P-256 for amd64 architectures in Go before 1.7.6 and 1.8.x before 1.8.2 causes incorrect results to be generated for specific input points. An adaptive attack can be mounted to progressively extract the scalar input to ScalarMult by submitting crafted points and observing failures to the derive correct output. This leads to a full key recovery attack against static ECDH, as used in popular JWT libraries. (<https://cve.circl.lu/cve/CVE-2017-8932>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: The net/http package in Go through 1.6 does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. (<https://cve.circl.lu/cve/CVE-2016-5386>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Int.Exp Montgomery code in the math/big library in Go 1.5.x before 1.5.3 mishandles carry propagation and produces incorrect output, which makes it easier for attackers to obtain private RSA keys via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-8618>)\n- <span style=\"color:#ff9c20\">Score: 7.2</span>: Untrusted search path vulnerability in Go before 1.5.4 and 1.6.x before 1.6.1 on Windows allows local users to gain privileges via a Trojan horse DLL in the current working directory, related to use of the LoadLibrary function. (<https://cve.circl.lu/cve/CVE-2016-3958>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Verify function in crypto/dsa/dsa.go in Go before 1.5.4 and 1.6.x before 1.6.1 does not properly check parameters passed to the big integer library, which might allow remote attackers to cause a denial of service (infinite loop) via a crafted public key to a program that uses HTTPS client certificates or SSH server libraries. (<https://cve.circl.lu/cve/CVE-2016-3959>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: crpyto/tls in Go 1.1 before 1.3.2, when SessionTicketsDisabled is enabled, allows man-in-the-middle attackers to spoof clients via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2014-7189>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Network Security Services - https://developer.mozilla.org/en-US/docs/NSS","descr":"Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.","Description":{"plain":"In computing, Network Security Services (NSS) comprises a set of libraries designed to support cross-platform development of security-enabled client and server applications with optional support for hardware TLS/SSL acceleration on the server side and hardware smart cards on the client side. NSS provides a complete open-source implementation of cryptographic libraries supporting Transport Layer Security (TLS) / Secure Sockets Layer (SSL) and S/MIME. Previously tri-licensed under the Mozilla Public License 1.1, the GNU General Public License, and the GNU Lesser General Public License, NSS upgraded to GPL-compatible MPL 2.0 with release 3.14.","childs":{"0":["In computing, Network Security Services (NSS) comprises a set of libraries designed to support cross-platform development of security-enabled client and server applications with optional support for hardware TLS/SSL acceleration on the server side and hardware smart cards on the client side. NSS provides a complete open-source implementation of cryptographic libraries supporting Transport Layer Security (TLS) / Secure Sockets Layer (SSL) and S/MIME. Previously tri-licensed under the Mozilla Public License 1.1, the GNU General Public License, and the GNU Lesser General Public License, NSS upgraded to GPL-compatible MPL 2.0 with release 3.14."]}},"Repository":{"plain":"- https://hg.mozilla.org/projects/nss\n","childs":{"0":[[{"content":"https://hg.mozilla.org/projects/nss","plain":"https://hg.mozilla.org/projects/nss\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- MPL 2.0\n","childs":{"0":[[{"content":"MPL 2.0","plain":"MPL 2.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Developers: Mozilla, AOL, Red Hat, Sun Microsystems, Oracle Corporation, Google and others\n- The information is applicable to the latest commit in the repository, not a specific release!\n","childs":{"0":[[{"content":"Developers: Mozilla, AOL, Red Hat, Sun Microsystems, Oracle Corporation, Google and others","plain":"Developers: Mozilla, AOL, Red Hat, Sun Microsystems, Oracle Corporation, Google and others\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"mozilla","childs":{"0":["mozilla"]}},"CVE Product":{"plain":"network_security_services","childs":{"0":["network_security_services"]}},"Interface Languages":{"plain":"","childs":{"0":[[{"content":"No Interface Languages specified","plain":"No Interface Languages specified","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A cached side channel attack during handshakes using RSA encryption could allow for the decryption of encrypted content. This is a variant of the Adaptive Chosen Ciphertext attack (AKA Bleichenbacher attack) and affects all NSS versions prior to NSS 3.41. (<https://cve.circl.lu/cve/CVE-2018-12404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: When handling a SSLv2-compatible ClientHello request, the server doesn't generate a new random value but sends an all-zero value instead. This results in full malleability of the ClientHello for SSLv2 used for TLS 1.2 in all versions prior to NSS 3.39. This does not impact TLS 1.3. (<https://cve.circl.lu/cve/CVE-2018-12384>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that Diffie Hellman Client key exchange handling in NSS 3.21.x was vulnerable to small subgroup confinement attack. An attacker could use this flaw to recover private keys by confining the client DH key to small subgroup of the desired group. (<https://cve.circl.lu/cve/CVE-2016-8635>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: nss before version 3.30 is vulnerable to a remote denial of service during the session handshake when using SessionTicket extension and ECDHE-ECDSA. (<https://cve.circl.lu/cve/CVE-2016-9574>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A flaw in DRBG number generation within the Network Security Services (NSS) library where the internal state V does not correctly carry bits over. The NSS library has been updated to fix this issue to address this issue and Firefox ESR 52.1 has been updated with NSS version 3.28.4. This vulnerability affects Thunderbird < 52.1, Firefox ESR < 45.9, Firefox ESR < 52.1, and Firefox < 53. (<https://cve.circl.lu/cve/CVE-2017-5462>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __get_page function in lib/dbm/src/h_page.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11698>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: The __hash_open function in hash.c:229 in Mozilla Network Security Services (NSS) allows context-dependent attackers to cause a denial of service (floating point exception and crash) via a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11697>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __hash_open function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11696>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the alloc_segs function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11695>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Null pointer dereference vulnerability in NSS since 3.24.0 was found when server receives empty SSLv2 messages resulting into denial of service by remote attacker. (<https://cve.circl.lu/cve/CVE-2017-7502>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.21.4, 3.22.x through 3.28.x before 3.28.4, 3.29.x before 3.29.5, and 3.30.x before 3.30.1 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact by leveraging incorrect base64 operations. (<https://cve.circl.lu/cve/CVE-2017-5461>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.16.2.1, 3.16.x before 3.16.5, and 3.17.x before 3.17.1, as used in Mozilla Firefox before 32.0.3, Mozilla Firefox ESR 24.x before 24.8.1 and 31.x before 31.1.1, Mozilla Thunderbird before 24.8.1 and 31.x before 31.1.2, Mozilla SeaMonkey before 2.29.1, Google Chrome before 37.0.2062.124 on Windows and OS X, and Google Chrome OS before 37.0.2062.120, does not properly parse ASN.1 values in X.509 certificates, which makes it easier for remote attackers to spoof RSA signatures via a crafted certificate, aka a \"signature malleability\" issue. (<https://cve.circl.lu/cve/CVE-2014-1568>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Use-after-free vulnerability in the CERT_DestroyCertificate function in libnss3.so in Mozilla Network Security Services (NSS) 3.x, as used in Firefox before 31.0, Firefox ESR 24.x before 24.7, and Thunderbird before 24.7, allows remote attackers to execute arbitrary code via vectors that trigger certain improper removal of an NSSCertificate structure from a trust domain. (<https://cve.circl.lu/cve/CVE-2014-1544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The cert_TestHostName function in lib/certdb/certdb.c in the certificate-checking implementation in Mozilla Network Security Services (NSS) before 3.16 accepts a wildcard character that is embedded in an internationalized domain name's U-label, which might allow man-in-the-middle attackers to spoof SSL servers via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2014-1492>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS protocol 1.2 and earlier, when a DHE_EXPORT ciphersuite is enabled on a server but not on a client, does not properly convey a DHE_EXPORT choice, which allows man-in-the-middle attackers to conduct cipher-downgrade attacks by rewriting a ClientHello with DHE replaced by DHE_EXPORT and then rewriting a ServerHello with DHE_EXPORT replaced by DHE, aka the \"Logjam\" issue. (<https://cve.circl.lu/cve/CVE-2015-4000>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, does not properly restrict public values in Diffie-Hellman key exchanges, which makes it easier for remote attackers to bypass cryptographic protection mechanisms in ticket handling by leveraging use of a certain value. (<https://cve.circl.lu/cve/CVE-2014-1491>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Race condition in libssl in Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors involving a resumption handshake that triggers incorrect replacement of a session ticket. (<https://cve.circl.lu/cve/CVE-2014-1490>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The CERT_VerifyCert function in lib/certhigh/certvfy.c in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 provides an unexpected return value for an incompatible key-usage certificate when the CERTVerifyLog argument is valid, which might allow remote attackers to bypass intended access restrictions via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-5606>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) 3.14 before 3.14.5 and 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via invalid handshake packets. (<https://cve.circl.lu/cve/CVE-2013-5605>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large size value. (<https://cve.circl.lu/cve/CVE-2013-1741>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.2 does not ensure that data structures are initialized before read operations, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a decryption failure. (<https://cve.circl.lu/cve/CVE-2013-1739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS implementation in Mozilla Network Security Services (NSS) does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1620>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The CERT_DecodeCertPackage function in Mozilla Network Security Services (NSS), as used in Mozilla Firefox before 20.0, Firefox ESR 17.x before 17.0.5, Thunderbird before 17.0.5, Thunderbird ESR 17.x before 17.0.5, SeaMonkey before 2.17, and other products, allows remote attackers to cause a denial of service (out-of-bounds read and memory corruption) via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-0791>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19.1, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, and other products, does not properly perform Elliptical Curve Cryptography (ECC) multiplications, which makes it easier for remote attackers to spoof ECDSA signatures via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-2730>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, Thunderbird before 38.1, and other products, does not properly determine state transitions for the TLS state machine, which allows man-in-the-middle attackers to defeat cryptographic protection mechanisms by blocking messages, as demonstrated by removing a forward-secrecy property by blocking a ServerKeyExchange message, aka a \"SMACK SKIP-TLS\" issue. (<https://cve.circl.lu/cve/CVE-2015-2721>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.20.2, as used in Mozilla Firefox before 43.0.2 and Firefox ESR 38.x before 38.5.2, does not reject MD5 signatures in Server Key Exchange messages in TLS 1.2 Handshake Protocol traffic, which makes it easier for man-in-the-middle attackers to spoof servers by triggering a collision. (<https://cve.circl.lu/cve/CVE-2015-7575>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in the PL_ARENA_ALLOCATE implementation in Netscape Portable Runtime (NSPR) in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption and application crash) via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-7183>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in the ASN.1 decoder in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data. (<https://cve.circl.lu/cve/CVE-2015-7182>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The sec_asn1d_parse_leaf function in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, improperly restricts access to an unspecified data structure, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data, related to a \"use-after-poison\" issue. (<https://cve.circl.lu/cve/CVE-2015-7181>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Use-after-free vulnerability in the PK11_ImportDERPrivateKeyInfoAndReturnKey function in Mozilla Network Security Services (NSS) before 3.21.1, as used in Mozilla Firefox before 45.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted key data with DER encoding. (<https://cve.circl.lu/cve/CVE-2016-1979>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Use-after-free vulnerability in the ssl3_HandleECDHServerKeyExchange function in Mozilla Network Security Services (NSS) before 3.21, as used in Mozilla Firefox before 44.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact by making an SSL (1) DHE or (2) ECDHE handshake at a time of high memory consumption. (<https://cve.circl.lu/cve/CVE-2016-1978>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in Mozilla Network Security Services (NSS) before 3.19.2.3 and 3.20.x and 3.21.x before 3.21.1, as used in Mozilla Firefox before 45.0 and Firefox ESR 38.x before 38.7, allows remote attackers to execute arbitrary code via crafted ASN.1 data in an X.509 certificate. (<https://cve.circl.lu/cve/CVE-2016-1950>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Mozilla Network Security Services (NSS) before 3.23, as used in Mozilla Firefox before 47.0, allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2834>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The ssl_Do1stHandshake function in sslsecur.c in libssl in Mozilla Network Security Services (NSS) before 3.15.4, when the TLS False Start feature is enabled, allows man-in-the-middle attackers to spoof SSL servers by using an arbitrary X.509 certificate during certain handshake traffic. (<https://cve.circl.lu/cve/CVE-2013-1740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in Netscape Network Security Services (NSS) library allows remote attackers to execute arbitrary code via a modified record length field in an SSLv2 client hello message. (<https://cve.circl.lu/cve/CVE-2004-0826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The definite_length_decoder function in lib/util/quickder.c in Mozilla Network Security Services (NSS) before 3.16.2.4 and 3.17.x before 3.17.3 does not ensure that the DER encoding of an ASN.1 length is properly formed, which allows remote attackers to conduct data-smuggling attacks by using a long byte sequence for an encoding, as demonstrated by the SEC_QuickDERDecodeItem function's improper handling of an arbitrary-length encoding of 0x00. (<https://cve.circl.lu/cve/CVE-2014-1569>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN.1 decoder in the QuickDER decoder in Mozilla Network Security Services (NSS) before 3.13.4, as used in Firefox 4.x through 12.0, Firefox ESR 10.x before 10.0.5, Thunderbird 5.0 through 12.0, Thunderbird ESR 10.x before 10.0.5, and SeaMonkey before 2.10, allows remote attackers to cause a denial of service (application crash) via a zero-length item, as demonstrated by (1) a zero-length basic constraint or (2) a zero-length field in an OCSP response. (<https://cve.circl.lu/cve/CVE-2012-0441>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Integer underflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, SeaMonkey before 1.0.8, Thunderbird before 1.5.0.10, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via a crafted SSLv2 server message containing a public key that is too short to encrypt the \"Master Secret\", which results in a heap-based overflow. (<https://cve.circl.lu/cve/CVE-2007-0008>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Stack-based buffer overflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, Thunderbird before 1.5.0.10, SeaMonkey before 1.0.8, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via invalid \"Client Master Key\" length values. (<https://cve.circl.lu/cve/CVE-2007-0009>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.7, Thunderbird before 1.5.0.7, and SeaMonkey before 1.0.5, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates, a similar vulnerability to CVE-2006-4339.  NOTE: on 20061107, Mozilla released an advisory stating that these versions were not completely patched by MFSA2006-60. The newer fixes for 1.5.0.7 are covered by CVE-2006-5462. (<https://cve.circl.lu/cve/CVE-2006-4340>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Heap-based buffer overflow in a regular-expression parser in Mozilla Network Security Services (NSS) before 3.12.3, as used in Firefox, Thunderbird, SeaMonkey, Evolution, Pidgin, and AOL Instant Messenger (AIM), allows remote SSL servers to cause a denial of service (application crash) or possibly execute arbitrary code via a long domain name in the subject's Common Name (CN) field of an X.509 certificate, related to the cert_TestHostName function. (<https://cve.circl.lu/cve/CVE-2009-2404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** Mozilla Network Security Services (NSS) 3.x, with certain settings of the SSL_ENABLE_RENEGOTIATION option, does not properly restrict client-initiated renegotiation within the SSL and TLS protocols, which might make it easier for remote attackers to cause a denial of service (CPU consumption) by performing many renegotiations within a single connection, a different vulnerability than CVE-2011-1473.  NOTE: it can also be argued that it is the responsibility of server deployments, not a security library, to prevent or limit renegotiation when it is inappropriate within a specific environment. (<https://cve.circl.lu/cve/CVE-2011-5094>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.8, Thunderbird before 1.5.0.8, and SeaMonkey before 1.0.6, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates. NOTE: this identifier is for unpatched product versions that were originally intended to be addressed by CVE-2006-4340. (<https://cve.circl.lu/cve/CVE-2006-5462>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A cached side channel attack during handshakes using RSA encryption could allow for the decryption of encrypted content. This is a variant of the Adaptive Chosen Ciphertext attack (AKA Bleichenbacher attack) and affects all NSS versions prior to NSS 3.41. (<https://cve.circl.lu/cve/CVE-2018-12404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: When handling a SSLv2-compatible ClientHello request, the server doesn't generate a new random value but sends an all-zero value instead. This results in full malleability of the ClientHello for SSLv2 used for TLS 1.2 in all versions prior to NSS 3.39. This does not impact TLS 1.3. (<https://cve.circl.lu/cve/CVE-2018-12384>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that Diffie Hellman Client key exchange handling in NSS 3.21.x was vulnerable to small subgroup confinement attack. An attacker could use this flaw to recover private keys by confining the client DH key to small subgroup of the desired group. (<https://cve.circl.lu/cve/CVE-2016-8635>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: nss before version 3.30 is vulnerable to a remote denial of service during the session handshake when using SessionTicket extension and ECDHE-ECDSA. (<https://cve.circl.lu/cve/CVE-2016-9574>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A flaw in DRBG number generation within the Network Security Services (NSS) library where the internal state V does not correctly carry bits over. The NSS library has been updated to fix this issue to address this issue and Firefox ESR 52.1 has been updated with NSS version 3.28.4. This vulnerability affects Thunderbird < 52.1, Firefox ESR < 45.9, Firefox ESR < 52.1, and Firefox < 53. (<https://cve.circl.lu/cve/CVE-2017-5462>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __get_page function in lib/dbm/src/h_page.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11698>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: The __hash_open function in hash.c:229 in Mozilla Network Security Services (NSS) allows context-dependent attackers to cause a denial of service (floating point exception and crash) via a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11697>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __hash_open function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11696>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the alloc_segs function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11695>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Null pointer dereference vulnerability in NSS since 3.24.0 was found when server receives empty SSLv2 messages resulting into denial of service by remote attacker. (<https://cve.circl.lu/cve/CVE-2017-7502>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.21.4, 3.22.x through 3.28.x before 3.28.4, 3.29.x before 3.29.5, and 3.30.x before 3.30.1 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact by leveraging incorrect base64 operations. (<https://cve.circl.lu/cve/CVE-2017-5461>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.16.2.1, 3.16.x before 3.16.5, and 3.17.x before 3.17.1, as used in Mozilla Firefox before 32.0.3, Mozilla Firefox ESR 24.x before 24.8.1 and 31.x before 31.1.1, Mozilla Thunderbird before 24.8.1 and 31.x before 31.1.2, Mozilla SeaMonkey before 2.29.1, Google Chrome before 37.0.2062.124 on Windows and OS X, and Google Chrome OS before 37.0.2062.120, does not properly parse ASN.1 values in X.509 certificates, which makes it easier for remote attackers to spoof RSA signatures via a crafted certificate, aka a \"signature malleability\" issue. (<https://cve.circl.lu/cve/CVE-2014-1568>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Use-after-free vulnerability in the CERT_DestroyCertificate function in libnss3.so in Mozilla Network Security Services (NSS) 3.x, as used in Firefox before 31.0, Firefox ESR 24.x before 24.7, and Thunderbird before 24.7, allows remote attackers to execute arbitrary code via vectors that trigger certain improper removal of an NSSCertificate structure from a trust domain. (<https://cve.circl.lu/cve/CVE-2014-1544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The cert_TestHostName function in lib/certdb/certdb.c in the certificate-checking implementation in Mozilla Network Security Services (NSS) before 3.16 accepts a wildcard character that is embedded in an internationalized domain name's U-label, which might allow man-in-the-middle attackers to spoof SSL servers via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2014-1492>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS protocol 1.2 and earlier, when a DHE_EXPORT ciphersuite is enabled on a server but not on a client, does not properly convey a DHE_EXPORT choice, which allows man-in-the-middle attackers to conduct cipher-downgrade attacks by rewriting a ClientHello with DHE replaced by DHE_EXPORT and then rewriting a ServerHello with DHE_EXPORT replaced by DHE, aka the \"Logjam\" issue. (<https://cve.circl.lu/cve/CVE-2015-4000>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, does not properly restrict public values in Diffie-Hellman key exchanges, which makes it easier for remote attackers to bypass cryptographic protection mechanisms in ticket handling by leveraging use of a certain value. (<https://cve.circl.lu/cve/CVE-2014-1491>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Race condition in libssl in Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors involving a resumption handshake that triggers incorrect replacement of a session ticket. (<https://cve.circl.lu/cve/CVE-2014-1490>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The CERT_VerifyCert function in lib/certhigh/certvfy.c in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 provides an unexpected return value for an incompatible key-usage certificate when the CERTVerifyLog argument is valid, which might allow remote attackers to bypass intended access restrictions via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-5606>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) 3.14 before 3.14.5 and 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via invalid handshake packets. (<https://cve.circl.lu/cve/CVE-2013-5605>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large size value. (<https://cve.circl.lu/cve/CVE-2013-1741>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.2 does not ensure that data structures are initialized before read operations, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a decryption failure. (<https://cve.circl.lu/cve/CVE-2013-1739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS implementation in Mozilla Network Security Services (NSS) does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1620>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The CERT_DecodeCertPackage function in Mozilla Network Security Services (NSS), as used in Mozilla Firefox before 20.0, Firefox ESR 17.x before 17.0.5, Thunderbird before 17.0.5, Thunderbird ESR 17.x before 17.0.5, SeaMonkey before 2.17, and other products, allows remote attackers to cause a denial of service (out-of-bounds read and memory corruption) via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-0791>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19.1, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, and other products, does not properly perform Elliptical Curve Cryptography (ECC) multiplications, which makes it easier for remote attackers to spoof ECDSA signatures via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-2730>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, Thunderbird before 38.1, and other products, does not properly determine state transitions for the TLS state machine, which allows man-in-the-middle attackers to defeat cryptographic protection mechanisms by blocking messages, as demonstrated by removing a forward-secrecy property by blocking a ServerKeyExchange message, aka a \"SMACK SKIP-TLS\" issue. (<https://cve.circl.lu/cve/CVE-2015-2721>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.20.2, as used in Mozilla Firefox before 43.0.2 and Firefox ESR 38.x before 38.5.2, does not reject MD5 signatures in Server Key Exchange messages in TLS 1.2 Handshake Protocol traffic, which makes it easier for man-in-the-middle attackers to spoof servers by triggering a collision. (<https://cve.circl.lu/cve/CVE-2015-7575>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in the PL_ARENA_ALLOCATE implementation in Netscape Portable Runtime (NSPR) in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption and application crash) via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-7183>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in the ASN.1 decoder in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data. (<https://cve.circl.lu/cve/CVE-2015-7182>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The sec_asn1d_parse_leaf function in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, improperly restricts access to an unspecified data structure, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data, related to a \"use-after-poison\" issue. (<https://cve.circl.lu/cve/CVE-2015-7181>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Use-after-free vulnerability in the PK11_ImportDERPrivateKeyInfoAndReturnKey function in Mozilla Network Security Services (NSS) before 3.21.1, as used in Mozilla Firefox before 45.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted key data with DER encoding. (<https://cve.circl.lu/cve/CVE-2016-1979>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Use-after-free vulnerability in the ssl3_HandleECDHServerKeyExchange function in Mozilla Network Security Services (NSS) before 3.21, as used in Mozilla Firefox before 44.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact by making an SSL (1) DHE or (2) ECDHE handshake at a time of high memory consumption. (<https://cve.circl.lu/cve/CVE-2016-1978>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in Mozilla Network Security Services (NSS) before 3.19.2.3 and 3.20.x and 3.21.x before 3.21.1, as used in Mozilla Firefox before 45.0 and Firefox ESR 38.x before 38.7, allows remote attackers to execute arbitrary code via crafted ASN.1 data in an X.509 certificate. (<https://cve.circl.lu/cve/CVE-2016-1950>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Mozilla Network Security Services (NSS) before 3.23, as used in Mozilla Firefox before 47.0, allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2834>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The ssl_Do1stHandshake function in sslsecur.c in libssl in Mozilla Network Security Services (NSS) before 3.15.4, when the TLS False Start feature is enabled, allows man-in-the-middle attackers to spoof SSL servers by using an arbitrary X.509 certificate during certain handshake traffic. (<https://cve.circl.lu/cve/CVE-2013-1740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in Netscape Network Security Services (NSS) library allows remote attackers to execute arbitrary code via a modified record length field in an SSLv2 client hello message. (<https://cve.circl.lu/cve/CVE-2004-0826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The definite_length_decoder function in lib/util/quickder.c in Mozilla Network Security Services (NSS) before 3.16.2.4 and 3.17.x before 3.17.3 does not ensure that the DER encoding of an ASN.1 length is properly formed, which allows remote attackers to conduct data-smuggling attacks by using a long byte sequence for an encoding, as demonstrated by the SEC_QuickDERDecodeItem function's improper handling of an arbitrary-length encoding of 0x00. (<https://cve.circl.lu/cve/CVE-2014-1569>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN.1 decoder in the QuickDER decoder in Mozilla Network Security Services (NSS) before 3.13.4, as used in Firefox 4.x through 12.0, Firefox ESR 10.x before 10.0.5, Thunderbird 5.0 through 12.0, Thunderbird ESR 10.x before 10.0.5, and SeaMonkey before 2.10, allows remote attackers to cause a denial of service (application crash) via a zero-length item, as demonstrated by (1) a zero-length basic constraint or (2) a zero-length field in an OCSP response. (<https://cve.circl.lu/cve/CVE-2012-0441>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Integer underflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, SeaMonkey before 1.0.8, Thunderbird before 1.5.0.10, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via a crafted SSLv2 server message containing a public key that is too short to encrypt the \"Master Secret\", which results in a heap-based overflow. (<https://cve.circl.lu/cve/CVE-2007-0008>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Stack-based buffer overflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, Thunderbird before 1.5.0.10, SeaMonkey before 1.0.8, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via invalid \"Client Master Key\" length values. (<https://cve.circl.lu/cve/CVE-2007-0009>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.7, Thunderbird before 1.5.0.7, and SeaMonkey before 1.0.5, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates, a similar vulnerability to CVE-2006-4339.  NOTE: on 20061107, Mozilla released an advisory stating that these versions were not completely patched by MFSA2006-60. The newer fixes for 1.5.0.7 are covered by CVE-2006-5462. (<https://cve.circl.lu/cve/CVE-2006-4340>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Heap-based buffer overflow in a regular-expression parser in Mozilla Network Security Services (NSS) before 3.12.3, as used in Firefox, Thunderbird, SeaMonkey, Evolution, Pidgin, and AOL Instant Messenger (AIM), allows remote SSL servers to cause a denial of service (application crash) or possibly execute arbitrary code via a long domain name in the subject's Common Name (CN) field of an X.509 certificate, related to the cert_TestHostName function. (<https://cve.circl.lu/cve/CVE-2009-2404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** Mozilla Network Security Services (NSS) 3.x, with certain settings of the SSL_ENABLE_RENEGOTIATION option, does not properly restrict client-initiated renegotiation within the SSL and TLS protocols, which might make it easier for remote attackers to cause a denial of service (CPU consumption) by performing many renegotiations within a single connection, a different vulnerability than CVE-2011-1473.  NOTE: it can also be argued that it is the responsibility of server deployments, not a security library, to prevent or limit renegotiation when it is inappropriate within a specific environment. (<https://cve.circl.lu/cve/CVE-2011-5094>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.8, Thunderbird before 1.5.0.8, and SeaMonkey before 1.0.6, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates. NOTE: this identifier is for unpatched product versions that were originally intended to be addressed by CVE-2006-4340. (<https://cve.circl.lu/cve/CVE-2006-5462>)","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A cached side channel attack during handshakes using RSA encryption could allow for the decryption of encrypted content. This is a variant of the Adaptive Chosen Ciphertext attack (AKA Bleichenbacher attack) and affects all NSS versions prior to NSS 3.41. (<https://cve.circl.lu/cve/CVE-2018-12404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: When handling a SSLv2-compatible ClientHello request, the server doesn't generate a new random value but sends an all-zero value instead. This results in full malleability of the ClientHello for SSLv2 used for TLS 1.2 in all versions prior to NSS 3.39. This does not impact TLS 1.3. (<https://cve.circl.lu/cve/CVE-2018-12384>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: It was found that Diffie Hellman Client key exchange handling in NSS 3.21.x was vulnerable to small subgroup confinement attack. An attacker could use this flaw to recover private keys by confining the client DH key to small subgroup of the desired group. (<https://cve.circl.lu/cve/CVE-2016-8635>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: nss before version 3.30 is vulnerable to a remote denial of service during the session handshake when using SessionTicket extension and ECDHE-ECDSA. (<https://cve.circl.lu/cve/CVE-2016-9574>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A flaw in DRBG number generation within the Network Security Services (NSS) library where the internal state V does not correctly carry bits over. The NSS library has been updated to fix this issue to address this issue and Firefox ESR 52.1 has been updated with NSS version 3.28.4. This vulnerability affects Thunderbird < 52.1, Firefox ESR < 45.9, Firefox ESR < 52.1, and Firefox < 53. (<https://cve.circl.lu/cve/CVE-2017-5462>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __get_page function in lib/dbm/src/h_page.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11698>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: The __hash_open function in hash.c:229 in Mozilla Network Security Services (NSS) allows context-dependent attackers to cause a denial of service (floating point exception and crash) via a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11697>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the __hash_open function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11696>)\n- <span style=\"color:#ffe000\">Score: 4.6</span>: Heap-based buffer overflow in the alloc_segs function in lib/dbm/src/hash.c in Mozilla Network Security Services (NSS) allows context-dependent attackers to have unspecified impact using a crafted cert8.db file. (<https://cve.circl.lu/cve/CVE-2017-11695>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Null pointer dereference vulnerability in NSS since 3.24.0 was found when server receives empty SSLv2 messages resulting into denial of service by remote attacker. (<https://cve.circl.lu/cve/CVE-2017-7502>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.21.4, 3.22.x through 3.28.x before 3.28.4, 3.29.x before 3.29.5, and 3.30.x before 3.30.1 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact by leveraging incorrect base64 operations. (<https://cve.circl.lu/cve/CVE-2017-5461>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) before 3.16.2.1, 3.16.x before 3.16.5, and 3.17.x before 3.17.1, as used in Mozilla Firefox before 32.0.3, Mozilla Firefox ESR 24.x before 24.8.1 and 31.x before 31.1.1, Mozilla Thunderbird before 24.8.1 and 31.x before 31.1.2, Mozilla SeaMonkey before 2.29.1, Google Chrome before 37.0.2062.124 on Windows and OS X, and Google Chrome OS before 37.0.2062.120, does not properly parse ASN.1 values in X.509 certificates, which makes it easier for remote attackers to spoof RSA signatures via a crafted certificate, aka a \"signature malleability\" issue. (<https://cve.circl.lu/cve/CVE-2014-1568>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Use-after-free vulnerability in the CERT_DestroyCertificate function in libnss3.so in Mozilla Network Security Services (NSS) 3.x, as used in Firefox before 31.0, Firefox ESR 24.x before 24.7, and Thunderbird before 24.7, allows remote attackers to execute arbitrary code via vectors that trigger certain improper removal of an NSSCertificate structure from a trust domain. (<https://cve.circl.lu/cve/CVE-2014-1544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The cert_TestHostName function in lib/certdb/certdb.c in the certificate-checking implementation in Mozilla Network Security Services (NSS) before 3.16 accepts a wildcard character that is embedded in an internationalized domain name's U-label, which might allow man-in-the-middle attackers to spoof SSL servers via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2014-1492>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS protocol 1.2 and earlier, when a DHE_EXPORT ciphersuite is enabled on a server but not on a client, does not properly convey a DHE_EXPORT choice, which allows man-in-the-middle attackers to conduct cipher-downgrade attacks by rewriting a ClientHello with DHE replaced by DHE_EXPORT and then rewriting a ServerHello with DHE_EXPORT replaced by DHE, aka the \"Logjam\" issue. (<https://cve.circl.lu/cve/CVE-2015-4000>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, does not properly restrict public values in Diffie-Hellman key exchanges, which makes it easier for remote attackers to bypass cryptographic protection mechanisms in ticket handling by leveraging use of a certain value. (<https://cve.circl.lu/cve/CVE-2014-1491>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Race condition in libssl in Mozilla Network Security Services (NSS) before 3.15.4, as used in Mozilla Firefox before 27.0, Firefox ESR 24.x before 24.3, Thunderbird before 24.3, SeaMonkey before 2.24, and other products, allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors involving a resumption handshake that triggers incorrect replacement of a session ticket. (<https://cve.circl.lu/cve/CVE-2014-1490>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The CERT_VerifyCert function in lib/certhigh/certvfy.c in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 provides an unexpected return value for an incompatible key-usage certificate when the CERTVerifyLog argument is valid, which might allow remote attackers to bypass intended access restrictions via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-5606>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Mozilla Network Security Services (NSS) 3.14 before 3.14.5 and 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via invalid handshake packets. (<https://cve.circl.lu/cve/CVE-2013-5605>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in Mozilla Network Security Services (NSS) 3.15 before 3.15.3 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large size value. (<https://cve.circl.lu/cve/CVE-2013-1741>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Mozilla Network Security Services (NSS) before 3.15.2 does not ensure that data structures are initialized before read operations, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a decryption failure. (<https://cve.circl.lu/cve/CVE-2013-1739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The TLS implementation in Mozilla Network Security Services (NSS) does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1620>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The CERT_DecodeCertPackage function in Mozilla Network Security Services (NSS), as used in Mozilla Firefox before 20.0, Firefox ESR 17.x before 17.0.5, Thunderbird before 17.0.5, Thunderbird ESR 17.x before 17.0.5, SeaMonkey before 2.17, and other products, allows remote attackers to cause a denial of service (out-of-bounds read and memory corruption) via a crafted certificate. (<https://cve.circl.lu/cve/CVE-2013-0791>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19.1, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, and other products, does not properly perform Elliptical Curve Cryptography (ECC) multiplications, which makes it easier for remote attackers to spoof ECDSA signatures via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-2730>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.19, as used in Mozilla Firefox before 39.0, Firefox ESR 31.x before 31.8 and 38.x before 38.1, Thunderbird before 38.1, and other products, does not properly determine state transitions for the TLS state machine, which allows man-in-the-middle attackers to defeat cryptographic protection mechanisms by blocking messages, as demonstrated by removing a forward-secrecy property by blocking a ServerKeyExchange message, aka a \"SMACK SKIP-TLS\" issue. (<https://cve.circl.lu/cve/CVE-2015-2721>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Mozilla Network Security Services (NSS) before 3.20.2, as used in Mozilla Firefox before 43.0.2 and Firefox ESR 38.x before 38.5.2, does not reject MD5 signatures in Server Key Exchange messages in TLS 1.2 Handshake Protocol traffic, which makes it easier for man-in-the-middle attackers to spoof servers by triggering a collision. (<https://cve.circl.lu/cve/CVE-2015-7575>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Integer overflow in the PL_ARENA_ALLOCATE implementation in Netscape Portable Runtime (NSPR) in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption and application crash) via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2015-7183>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in the ASN.1 decoder in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data. (<https://cve.circl.lu/cve/CVE-2015-7182>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The sec_asn1d_parse_leaf function in Mozilla Network Security Services (NSS) before 3.19.2.1 and 3.20.x before 3.20.1, as used in Firefox before 42.0 and Firefox ESR 38.x before 38.4 and other products, improperly restricts access to an unspecified data structure, which allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted OCTET STRING data, related to a \"use-after-poison\" issue. (<https://cve.circl.lu/cve/CVE-2015-7181>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Use-after-free vulnerability in the PK11_ImportDERPrivateKeyInfoAndReturnKey function in Mozilla Network Security Services (NSS) before 3.21.1, as used in Mozilla Firefox before 45.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted key data with DER encoding. (<https://cve.circl.lu/cve/CVE-2016-1979>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Use-after-free vulnerability in the ssl3_HandleECDHServerKeyExchange function in Mozilla Network Security Services (NSS) before 3.21, as used in Mozilla Firefox before 44.0, allows remote attackers to cause a denial of service or possibly have unspecified other impact by making an SSL (1) DHE or (2) ECDHE handshake at a time of high memory consumption. (<https://cve.circl.lu/cve/CVE-2016-1978>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in Mozilla Network Security Services (NSS) before 3.19.2.3 and 3.20.x and 3.21.x before 3.21.1, as used in Mozilla Firefox before 45.0 and Firefox ESR 38.x before 38.7, allows remote attackers to execute arbitrary code via crafted ASN.1 data in an X.509 certificate. (<https://cve.circl.lu/cve/CVE-2016-1950>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Mozilla Network Security Services (NSS) before 3.23, as used in Mozilla Firefox before 47.0, allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact via unknown vectors. (<https://cve.circl.lu/cve/CVE-2016-2834>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: The ssl_Do1stHandshake function in sslsecur.c in libssl in Mozilla Network Security Services (NSS) before 3.15.4, when the TLS False Start feature is enabled, allows man-in-the-middle attackers to spoof SSL servers by using an arbitrary X.509 certificate during certain handshake traffic. (<https://cve.circl.lu/cve/CVE-2013-1740>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Heap-based buffer overflow in Netscape Network Security Services (NSS) library allows remote attackers to execute arbitrary code via a modified record length field in an SSLv2 client hello message. (<https://cve.circl.lu/cve/CVE-2004-0826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The definite_length_decoder function in lib/util/quickder.c in Mozilla Network Security Services (NSS) before 3.16.2.4 and 3.17.x before 3.17.3 does not ensure that the DER encoding of an ASN.1 length is properly formed, which allows remote attackers to conduct data-smuggling attacks by using a long byte sequence for an encoding, as demonstrated by the SEC_QuickDERDecodeItem function's improper handling of an arbitrary-length encoding of 0x00. (<https://cve.circl.lu/cve/CVE-2014-1569>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN.1 decoder in the QuickDER decoder in Mozilla Network Security Services (NSS) before 3.13.4, as used in Firefox 4.x through 12.0, Firefox ESR 10.x before 10.0.5, Thunderbird 5.0 through 12.0, Thunderbird ESR 10.x before 10.0.5, and SeaMonkey before 2.10, allows remote attackers to cause a denial of service (application crash) via a zero-length item, as demonstrated by (1) a zero-length basic constraint or (2) a zero-length field in an OCSP response. (<https://cve.circl.lu/cve/CVE-2012-0441>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Integer underflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, SeaMonkey before 1.0.8, Thunderbird before 1.5.0.10, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via a crafted SSLv2 server message containing a public key that is too short to encrypt the \"Master Secret\", which results in a heap-based overflow. (<https://cve.circl.lu/cve/CVE-2007-0008>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Stack-based buffer overflow in the SSLv2 support in Mozilla Network Security Services (NSS) before 3.11.5, as used by Firefox before 1.5.0.10 and 2.x before 2.0.0.2, Thunderbird before 1.5.0.10, SeaMonkey before 1.0.8, and certain Sun Java System server products before 20070611, allows remote attackers to execute arbitrary code via invalid \"Client Master Key\" length values. (<https://cve.circl.lu/cve/CVE-2007-0009>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.7, Thunderbird before 1.5.0.7, and SeaMonkey before 1.0.5, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates, a similar vulnerability to CVE-2006-4339.  NOTE: on 20061107, Mozilla released an advisory stating that these versions were not completely patched by MFSA2006-60. The newer fixes for 1.5.0.7 are covered by CVE-2006-5462. (<https://cve.circl.lu/cve/CVE-2006-4340>)\n- <span style=\"color:#ff0000\">Score: 9.3</span>: Heap-based buffer overflow in a regular-expression parser in Mozilla Network Security Services (NSS) before 3.12.3, as used in Firefox, Thunderbird, SeaMonkey, Evolution, Pidgin, and AOL Instant Messenger (AIM), allows remote SSL servers to cause a denial of service (application crash) or possibly execute arbitrary code via a long domain name in the subject's Common Name (CN) field of an X.509 certificate, related to the cert_TestHostName function. (<https://cve.circl.lu/cve/CVE-2009-2404>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** Mozilla Network Security Services (NSS) 3.x, with certain settings of the SSL_ENABLE_RENEGOTIATION option, does not properly restrict client-initiated renegotiation within the SSL and TLS protocols, which might make it easier for remote attackers to cause a denial of service (CPU consumption) by performing many renegotiations within a single connection, a different vulnerability than CVE-2011-1473.  NOTE: it can also be argued that it is the responsibility of server deployments, not a security library, to prevent or limit renegotiation when it is inappropriate within a specific environment. (<https://cve.circl.lu/cve/CVE-2011-5094>)\n- <span style=\"color:#ffbc10\">Score: 6.4</span>: Mozilla Network Security Service (NSS) library before 3.11.3, as used in Mozilla Firefox before 1.5.0.8, Thunderbird before 1.5.0.8, and SeaMonkey before 1.0.6, when using an RSA key with exponent 3, does not properly handle extra data in a signature, which allows remote attackers to forge signatures for SSL/TLS and email certificates. NOTE: this identifier is for unpatched product versions that were originally intended to be addressed by CVE-2006-4340. (<https://cve.circl.lu/cve/CVE-2006-5462>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Botan  2.0.0 - https://botan.randombit.net/","descr":"Botan is a BSD-licensed cryptographic library written in C++. It provides a wide variety of cryptographic algorithms, formats, and protocols, e.g. SSL and TLS. It is used in the Monotone distributed revision control program, the OpenDNSSEC system, and ISC's Kea DHCP server among other projects.","License":{"plain":"- BSD-2-Clause\n","childs":{"0":[[{"content":"BSD-2-Clause","plain":"BSD-2-Clause\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available.","childs":{"0":["Botan's goal is to be the best option for cryptography in new C++ code by offering the tools necessary to implement a range of practical systems, such as TLS/DTLS, PKIX certificate handling, PKCS#11 and TPM hardware support, password hashing, and post quantum crypto schemes. In addition to the C++, botan has a C89 API specifically designed to be easy to call from other languages. A Python binding using ctypes is included, and several other language bindings are available."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/randombit/botan>\n    - Last repository change: 2019-10-16T16:38:00\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"Archive":{"plain":"- https://github.com/randombit/botan/archive/2.0.0.zip\n","childs":{"0":[[{"content":"https://github.com/randombit/botan/archive/2.0.0.zip","plain":"https://github.com/randombit/botan/archive/2.0.0.zip\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++11\n","childs":{"0":[[{"content":"C++11","plain":"C++11\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release Date: 2017-01-07\n- Release: 2.0.0\n","childs":{"0":[[{"content":"Release Date: 2017-01-07","plain":"Release Date: 2017-01-07\n","plainChilds":"","childs":[]},{"content":"Release: 2.0.0","plain":"Release: 2.0.0","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"botan_project","childs":{"0":["botan_project"]}},"CVE Product":{"plain":"botan","childs":{"0":["botan"]}},"Development Languages":{"plain":"- C++\n- Python\n- C\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"C","plain":"C","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"CAST-256","plain":"CAST-256","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"KASUMI","plain":"KASUMI","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MISTY1","plain":"MISTY1","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"BPS","plain":"BPS","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"McEliece","plain":"McEliece","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: A side-channel issue was discovered in Botan before 2.9.0. An attacker capable of precisely measuring the time taken for ECC key generation may be able to derive information about the high bits of the secret key, as the function to derive the public point from the secret scalar uses an unblinded Montgomery ladder whose loop iteration count depends on the bitlength of the secret. This issue affects only key generation, not ECDSA signatures or ECDH key agreement. (<https://cve.circl.lu/cve/CVE-2018-20187>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Botan 2.5.0 through 2.6.0 before 2.7.0 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP, related to dsa/dsa.cpp, ec_group/ec_group.cpp, and ecdsa/ecdsa.cpp. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12435>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: An issue was discovered in Botan 1.11.32 through 2.x before 2.6.0. An off-by-one error when processing malformed TLS-CBC ciphertext could cause the receiving side to include in the HMAC computation exactly 64K bytes of data following the record buffer, aka an over-read. The MAC comparison will subsequently fail and the connection will be closed. This could be used for denial of service. No information leak occurs. (<https://cve.circl.lu/cve/CVE-2018-9860>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Botan 2.2.0 - 2.4.0 (fixed in 2.5.0) improperly handled wildcard certificates and could accept certain certificates as valid for hostnames when, under RFC 6125 rules, they should not match. This only affects certificates issued to the same domain as the host, so to impersonate a host one must already have a wildcard certificate matching other hosts in the same domain. For example, b*.example.com would match some hostnames that do not begin with a 'b' character. (<https://cve.circl.lu/cve/CVE-2018-9127>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A cryptographic cache-based side channel in the RSA implementation in Botan before 1.10.17, and 1.11.x and 2.x before 2.3.0, allows a local attacker to recover information about RSA secret keys, as demonstrated by CacheD. This occurs because an array is indexed with bits derived from a secret key. (<https://cve.circl.lu/cve/CVE-2017-14737>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: A programming error exists in a way Randombit Botan cryptographic library version 2.0.1 implements x500 string comparisons which could lead to certificate verification issues and abuse. A specially crafted X509 certificate would need to be delivered to the client or server application in order to trigger this vulnerability. (<https://cve.circl.lu/cve/CVE-2017-2801>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The X509_Certificate::allowed_usage function in botan 1.11.x before 1.11.31 might allow attackers to have unspecified impact by leveraging a call with more than one Key_Usage set in the enum value. (<https://cve.circl.lu/cve/CVE-2016-6879>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: The Curve25519 code in botan before 1.11.31, on systems without a native 128-bit integer type, might allow attackers to have unspecified impact via vectors related to undefined behavior, as demonstrated on 32-bit ARM systems compiled by Clang. (<https://cve.circl.lu/cve/CVE-2016-6878>)\n- <span style=\"color:#ffe000\">Score: 5</span>: botan 1.11.x before 1.11.22 makes it easier for remote attackers to decrypt TLS ciphertext data via a padding-oracle attack against TLS CBC ciphersuites. (<https://cve.circl.lu/cve/CVE-2015-7824>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: botan before 1.11.22 improperly validates certificate paths, which allows remote attackers to cause a denial of service (infinite loop and memory consumption) via a certificate with a loop in the certificate chain. (<https://cve.circl.lu/cve/CVE-2015-7825>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: botan 1.11.x before 1.11.22 improperly handles wildcard matching against hostnames, which might allow remote attackers to have unspecified impact via a valid X.509 certificate, as demonstrated by accepting *.example.com as a match for bar.foo.example.com. (<https://cve.circl.lu/cve/CVE-2015-7826>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: In Botan 1.8.0 through 1.11.33, when decoding BER data an integer overflow could occur, which would cause an incorrect length field to be computed. Some API callers may use the returned (incorrect and attacker controlled) length field in a way which later causes memory corruption or other failure. (<https://cve.circl.lu/cve/CVE-2016-9132>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: In Botan 1.11.29 through 1.11.32, RSA decryption with certain padding options had a detectable timing channel which could given sufficient queries be used to recover plaintext, aka an \"OAEP side channel\" attack. (<https://cve.circl.lu/cve/CVE-2016-8871>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Botan before 1.10.13 and 1.11.x before 1.11.22 make it easier for remote attackers to conduct million-message attacks by measuring time differences, related to decoding of PKCS#1 padding. (<https://cve.circl.lu/cve/CVE-2015-7827>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan before 1.10.13 and 1.11.x before 1.11.29 do not use a constant-time algorithm to perform a modular inverse on the signature nonce k, which might allow remote attackers to obtain ECDSA secret keys via a timing side-channel attack. (<https://cve.circl.lu/cve/CVE-2016-2849>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Botan 1.11.x before 1.11.29 does not enforce TLS policy for (1) signature algorithms and (2) ECC curves, which allows remote attackers to conduct downgrade attacks via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2850>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ressol function in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (infinite loop) via unspecified input to the OS2ECP function, related to a composite modulus. (<https://cve.circl.lu/cve/CVE-2016-2194>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Integer overflow in the PointGFp constructor in Botan before 1.10.11 and 1.11.x before 1.11.27 allows remote attackers to overwrite memory and possibly execute arbitrary code via a crafted ECC point, which triggers a heap-based buffer overflow. (<https://cve.circl.lu/cve/CVE-2016-2195>)\n- <span style=\"color:#ff0000\">Score: 10</span>: Heap-based buffer overflow in the P-521 reduction function in Botan 1.11.x before 1.11.27 allows remote attackers to cause a denial of service (memory overwrite and crash) or execute arbitrary code via unspecified vectors. (<https://cve.circl.lu/cve/CVE-2016-2196>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The BER decoder in Botan 0.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (application crash) via an empty BIT STRING in ASN.1 data. (<https://cve.circl.lu/cve/CVE-2015-5726>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The Miller-Rabin primality check in Botan before 1.10.8 and 1.11.x before 1.11.9 improperly uses a single random base, which makes it easier for remote attackers to defeat cryptographic protection mechanisms via a DH group. (<https://cve.circl.lu/cve/CVE-2014-9742>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: The BER decoder in Botan 1.10.x before 1.10.10 and 1.11.x before 1.11.19 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors, related to a length field. (<https://cve.circl.lu/cve/CVE-2015-5727>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Kyber - https://godoc.org/github.com/dedis/kyber","descr":"Advanced crypto library for the Go language","Description":{"plain":"Package kyber provides a toolbox of advanced cryptographic primitives, for applications that need more than straightforward signing and encryption. This top level package defines the interfaces to cryptographic primitives designed to be independent of specific cryptographic algorithms, to facilitate upgrading applications to new cryptographic algorithms or switching to alternative algorithms for experimentation purposes.","childs":{"0":["Package kyber provides a toolbox of advanced cryptographic primitives, for applications that need more than straightforward signing and encryption. This top level package defines the interfaces to cryptographic primitives designed to be independent of specific cryptographic algorithms, to facilitate upgrading applications to new cryptographic algorithms or switching to alternative algorithms for experimentation purposes."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/dedis/kyber>\n    - Last repository change: 2019-10-14T14:01:08\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- MPL-2.0\n","childs":{"0":[[{"content":"MPL-2.0","plain":"MPL-2.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Requires Go version 1.8+\n- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 300\n","childs":{"0":[[{"content":"Requires Go version 1.8+","plain":"Requires Go version 1.8+\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 300","plain":"Stars: 300","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- Go\n","childs":{"0":[[{"content":"Go","plain":"Go\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- Go\n- C\n","childs":{"0":[[{"content":"Go","plain":"Go","plainChilds":"","childs":[]},{"content":"C","plain":"C","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"StreamCryptor - https://github.com/bitbeans/StreamCryptor","descr":"Stream encryption & decryption with libsodium and protobuf","Description":{"plain":"You can use StreamCryptor to encrypt and decrypt files without size limit and the need to load every file completely into memory. StreamCryptor uses FileStream to read and write files in chunks, there is also an asynchronous implementations for progress reporting available: example. For more working examples check out the tests in this repository.\n\nFiles are encrypted into SCCEF (StreamCryptor Chunked Encrypted File) format. Every file contains an EncryptedFileHeader some EncryptedFileChunks and an EncryptedFileFooter to prevent file manipulation.\n\nThe file serialization is realised with Google`s protobuf, it has a small overhead and offers an automatic length prefix for all file parts. All cryptographic operations are performed via libsodium-net and thus libsodium), see Algorithm details.\n\nTo protect the senders PublicKey from beeing tracked, you should use an ephemeral key pair for every file. If you do this it isn't possible to authenticate who encrypted the file!","childs":{"0":["You can use StreamCryptor to encrypt and decrypt files without size limit and the need to load every file completely into memory. StreamCryptor uses FileStream to read and write files in chunks, there is also an asynchronous implementations for progress reporting available: example. For more working examples check out the tests in this repository.","Files are encrypted into SCCEF (StreamCryptor Chunked Encrypted File) format. Every file contains an EncryptedFileHeader some EncryptedFileChunks and an EncryptedFileFooter to prevent file manipulation.","The file serialization is realised with Google`s protobuf, it has a small overhead and offers an automatic length prefix for all file parts. All cryptographic operations are performed via libsodium-net and thus libsodium), see Algorithm details.","To protect the senders PublicKey from beeing tracked, you should use an ephemeral key pair for every file. If you do this it isn't possible to authenticate who encrypted the file!"]}},"Repository":{"plain":"- Inactive\n","childs":{"0":[[{"content":"Inactive","plain":"Inactive\n","plainChilds":"    - <https://github.com/bitbeans/StreamCryptor>\n    - Last repository change: 2017-03-10T18:18:28\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- ,[Link to Audit-Report 04.2015]\n- This library targets .NET 4.5.\n- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 96\n","childs":{"0":[[{"content":",[Link to Audit-Report 04.2015]","plain":"[Link to Audit-Report 04.2015](https://cure53.de/pentest-report_streamcryptor.pdf)\n","plainChilds":"","childs":[]},{"content":"This library targets .NET 4.5.","plain":"This library targets .NET 4.5.\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 96","plain":"Stars: 96","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C#\u0000","childs":{"0":[[{"content":"C#","plain":"C#\u0000","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"NaCL - https://nacl.cr.yp.to/","descr":"NaCl (pronounced \"salt\") is a new easy-to-use high-speed software library for network communication, encryption, decryption, signatures, etc. NaCl's goal is to provide all of the core operations needed to build higher-level cryptographic tools.","Description":{"plain":"NaCl (pronounced \"salt\") is an abbreviation for \"Networking and Cryptography library\", a public domain \"...high-speed software library for network communication, encryption, decryption, signatures, etc\".\nNaCl was created by the mathematician and programmer Daniel J. Bernstein who is best known for the creation of qmail and Curve25519. The core team also includes Tanja Lange and Peter Schwabe. The main goal while creating NaCl, according to the paper, was to \"avoid various types of cryptographic disasters suffered by previous cryptographic libraries\".","childs":{"0":["NaCl (pronounced \"salt\") is an abbreviation for \"Networking and Cryptography library\", a public domain \"...high-speed software library for network communication, encryption, decryption, signatures, etc\". NaCl was created by the mathematician and programmer Daniel J. Bernstein who is best known for the creation of qmail and Curve25519. The core team also includes Tanja Lange and Peter Schwabe. The main goal while creating NaCl, according to the paper, was to \"avoid various types of cryptographic disasters suffered by previous cryptographic libraries\"."]}},"Repository":{"plain":"","childs":{"0":[[{"content":"No Repository specified","plain":"No Repository specified","plainChilds":"","childs":[]}]]}},"License":{"plain":"- Public domain\n","childs":{"0":[[{"content":"Public domain","plain":"Public domain\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Original authors: Daniel J. Bernstein, Tanja Lange, Peter Schwabe\n- Initial release: 2008\n- Operating system: UNIX-like\n","childs":{"0":[[{"content":"Original authors: Daniel J. Bernstein, Tanja Lange, Peter Schwabe","plain":"Original authors: Daniel J. Bernstein, Tanja Lange, Peter Schwabe\n","plainChilds":"","childs":[]},{"content":"Initial release: 2008","plain":"Initial release: 2008\n","plainChilds":"","childs":[]},{"content":"Operating system: UNIX-like","plain":"Operating system: UNIX-like\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"","childs":{"0":[[{"content":"No Interface Languages specified","plain":"No Interface Languages specified","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"mbed TLS - https://tls.mbed.org/","descr":"mbed TLS (formerly known as PolarSSL) makes it trivially easy for developers to include cryptographic and SSL/TLS capabilities in their (embedded) products, facilitating this functionality with a minimal coding footprint.","Description":{"plain":"mbed TLS offers an SSL library with an intuitive API and readable source code, so you can actually understand what the code does. Also the mbed TLS modules are as loosely coupled as possible and written in the portable C language. This allows you to use the parts you need, without having to include the total library","childs":{"0":["mbed TLS offers an SSL library with an intuitive API and readable source code, so you can actually understand what the code does. Also the mbed TLS modules are as loosely coupled as possible and written in the portable C language. This allows you to use the parts you need, without having to include the total library"]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/ARMmbed/mbedtls>\n    - Last repository change: 2019-10-14T08:19:07\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Apache-2.0\n","childs":{"0":[[{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"arm","childs":{"0":["arm"]}},"CVE Product":{"plain":"mbed_tls","childs":{"0":["mbed_tls"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 2122\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 2122","plain":"Stars: 2122","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"XTEA","plain":"XTEA","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Vernam","plain":"Vernam","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#00f000\">Score: 2.6</span>: Arm Mbed TLS before 2.19.0 and Arm Mbed Crypto before 2.0.0, when deterministic ECDSA is enabled, use an RNG with insufficient entropy for blinding, which might allow an attacker to recover a private key via side-channel attacks if a victim signs the same message many times. (For Mbed TLS, the fix is also available in versions 2.7.12 and 2.16.3.) (<https://cve.circl.lu/cve/CVE-2019-16910>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Arm Mbed TLS before 2.14.1, before 2.7.8, and before 2.1.17 allows a local unprivileged attacker to recover the plaintext of RSA decryption, which is used in RSA-without-(EC)DH(E) cipher suites. (<https://cve.circl.lu/cve/CVE-2018-19608>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows local users to achieve partial plaintext recovery (for a CBC based ciphersuite) via a cache-based side-channel attack. (<https://cve.circl.lu/cve/CVE-2018-0498>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows remote attackers to achieve partial plaintext recovery (for a CBC based ciphersuite) via a timing-based side-channel attack. This vulnerability exists because of an incorrect fix (with a wrong SHA-384 calculation) for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2018-0497>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9989>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9988>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0, when the truncated HMAC extension and CBC are used, allows remote attackers to execute arbitrary code or cause a denial of service (heap corruption) via a crafted application packet within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0488>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0 allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via a crafted certificate chain that is mishandled during RSASSA-PSS signature verification within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0487>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected. (<https://cve.circl.lu/cve/CVE-2017-14032>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: An exploitable free of a stack pointer vulnerability exists in the x509 certificate parsing code of ARM mbed TLS before 1.3.19, 2.x before 2.1.7, and 2.4.x before 2.4.2. A specially crafted x509 certificate, when parsed by mbed TLS library, can cause an invalid free of a stack pointer leading to a potential remote code execution. In order to exploit this vulnerability, an attacker can act as either a client or a server on a network to deliver malicious x509 certificates to vulnerable applications. (<https://cve.circl.lu/cve/CVE-2017-2784>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message.  NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0. (<https://cve.circl.lu/cve/CVE-2015-5291>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long session ticket name to the session ticket extension, which is not properly handled when creating a ClientHello message to resume a session.  NOTE: this identifier was SPLIT from CVE-2015-5291 per ADT3 due to different affected version ranges. (<https://cve.circl.lu/cve/CVE-2015-8036>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#00f000\">Score: 2.6</span>: Arm Mbed TLS before 2.19.0 and Arm Mbed Crypto before 2.0.0, when deterministic ECDSA is enabled, use an RNG with insufficient entropy for blinding, which might allow an attacker to recover a private key via side-channel attacks if a victim signs the same message many times. (For Mbed TLS, the fix is also available in versions 2.7.12 and 2.16.3.) (<https://cve.circl.lu/cve/CVE-2019-16910>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Arm Mbed TLS before 2.14.1, before 2.7.8, and before 2.1.17 allows a local unprivileged attacker to recover the plaintext of RSA decryption, which is used in RSA-without-(EC)DH(E) cipher suites. (<https://cve.circl.lu/cve/CVE-2018-19608>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows local users to achieve partial plaintext recovery (for a CBC based ciphersuite) via a cache-based side-channel attack. (<https://cve.circl.lu/cve/CVE-2018-0498>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows remote attackers to achieve partial plaintext recovery (for a CBC based ciphersuite) via a timing-based side-channel attack. This vulnerability exists because of an incorrect fix (with a wrong SHA-384 calculation) for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2018-0497>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9989>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9988>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0, when the truncated HMAC extension and CBC are used, allows remote attackers to execute arbitrary code or cause a denial of service (heap corruption) via a crafted application packet within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0488>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0 allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via a crafted certificate chain that is mishandled during RSASSA-PSS signature verification within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0487>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected. (<https://cve.circl.lu/cve/CVE-2017-14032>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: An exploitable free of a stack pointer vulnerability exists in the x509 certificate parsing code of ARM mbed TLS before 1.3.19, 2.x before 2.1.7, and 2.4.x before 2.4.2. A specially crafted x509 certificate, when parsed by mbed TLS library, can cause an invalid free of a stack pointer leading to a potential remote code execution. In order to exploit this vulnerability, an attacker can act as either a client or a server on a network to deliver malicious x509 certificates to vulnerable applications. (<https://cve.circl.lu/cve/CVE-2017-2784>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message.  NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0. (<https://cve.circl.lu/cve/CVE-2015-5291>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long session ticket name to the session ticket extension, which is not properly handled when creating a ClientHello message to resume a session.  NOTE: this identifier was SPLIT from CVE-2015-5291 per ADT3 due to different affected version ranges. (<https://cve.circl.lu/cve/CVE-2015-8036>)","plain":"- <span style=\"color:#00f000\">Score: 2.6</span>: Arm Mbed TLS before 2.19.0 and Arm Mbed Crypto before 2.0.0, when deterministic ECDSA is enabled, use an RNG with insufficient entropy for blinding, which might allow an attacker to recover a private key via side-channel attacks if a victim signs the same message many times. (For Mbed TLS, the fix is also available in versions 2.7.12 and 2.16.3.) (<https://cve.circl.lu/cve/CVE-2019-16910>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Arm Mbed TLS before 2.14.1, before 2.7.8, and before 2.1.17 allows a local unprivileged attacker to recover the plaintext of RSA decryption, which is used in RSA-without-(EC)DH(E) cipher suites. (<https://cve.circl.lu/cve/CVE-2018-19608>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows local users to achieve partial plaintext recovery (for a CBC based ciphersuite) via a cache-based side-channel attack. (<https://cve.circl.lu/cve/CVE-2018-0498>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ARM mbed TLS before 2.12.0, before 2.7.5, and before 2.1.14 allows remote attackers to achieve partial plaintext recovery (for a CBC based ciphersuite) via a timing-based side-channel attack. This vulnerability exists because of an incorrect fix (with a wrong SHA-384 calculation) for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2018-0497>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_psk_hint() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9989>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input. (<https://cve.circl.lu/cve/CVE-2018-9988>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0, when the truncated HMAC extension and CBC are used, allows remote attackers to execute arbitrary code or cause a denial of service (heap corruption) via a crafted application packet within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0488>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: ARM mbed TLS before 1.3.22, before 2.1.10, and before 2.7.0 allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow) via a crafted certificate chain that is mishandled during RSASSA-PSS signature verification within a TLS or DTLS session. (<https://cve.circl.lu/cve/CVE-2018-0487>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected. (<https://cve.circl.lu/cve/CVE-2017-14032>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: An exploitable free of a stack pointer vulnerability exists in the x509 certificate parsing code of ARM mbed TLS before 1.3.19, 2.x before 2.1.7, and 2.4.x before 2.4.2. A specially crafted x509 certificate, when parsed by mbed TLS library, can cause an invalid free of a stack pointer leading to a potential remote code execution. In order to exploit this vulnerability, an attacker can act as either a client or a server on a network to deliver malicious x509 certificates to vulnerable applications. (<https://cve.circl.lu/cve/CVE-2017-2784>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in PolarSSL 1.x before 1.2.17 and ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long hostname to the server name indication (SNI) extension, which is not properly handled when creating a ClientHello message.  NOTE: this identifier has been SPLIT per ADT3 due to different affected version ranges. See CVE-2015-8036 for the session ticket issue that was introduced in 1.3.0. (<https://cve.circl.lu/cve/CVE-2015-5291>)\n- <span style=\"color:#ffbc10\">Score: 6.8</span>: Heap-based buffer overflow in ARM mbed TLS (formerly PolarSSL) 1.3.x before 1.3.14 and 2.x before 2.1.2 allows remote SSL servers to cause a denial of service (client crash) and possibly execute arbitrary code via a long session ticket name to the session ticket extension, which is not properly handled when creating a ClientHello message to resume a session.  NOTE: this identifier was SPLIT from CVE-2015-5291 per ADT3 due to different affected version ranges. (<https://cve.circl.lu/cve/CVE-2015-8036>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"libsodium net - https://github.com/adamcaudill/libsodium-net","descr":"libsodium for .NET - A secure cryptographic library","Description":{"plain":"libsodium-net, or better said, libsodium for .NET, is a C# wrapper around libsodium. For those that don't know, libsodium is a portable implementation of Daniel Bernstein's fantastic NaCl library. If you aren't familiar with NaCl, I highly suggest that you look into libsodium and NaCl before using this library. \n\nNaCl is a great library in that its designed has made the right choices on what to implement and how - something most developers don't know how to do. So by using it (or a wrapper), many of those details are abstracted away where you don't need to worry about them. NaCl itself is less than portable C, only targeted for *nix systems; libsodium solves this by making it portable and making a few minor changes to better suite being distributed as a compiled binary.\n\nCrypto is hard - much harder than your average developer understands. This effort was started to make these tools readily available to the .NET community in hopes they will be used to further the goals of defending personal privacy and security.","childs":{"0":["libsodium-net, or better said, libsodium for .NET, is a C# wrapper around libsodium. For those that don't know, libsodium is a portable implementation of Daniel Bernstein's fantastic NaCl library. If you aren't familiar with NaCl, I highly suggest that you look into libsodium and NaCl before using this library. ","NaCl is a great library in that its designed has made the right choices on what to implement and how - something most developers don't know how to do. So by using it (or a wrapper), many of those details are abstracted away where you don't need to worry about them. NaCl itself is less than portable C, only targeted for *nix systems; libsodium solves this by making it portable and making a few minor changes to better suite being distributed as a compiled binary.","Crypto is hard - much harder than your average developer understands. This effort was started to make these tools readily available to the .NET community in hopes they will be used to further the goals of defending personal privacy and security."]}},"Repository":{"plain":"- Inactive\n","childs":{"0":[[{"content":"Inactive","plain":"Inactive\n","plainChilds":"    - <https://github.com/adamcaudill/libsodium-net>\n    - Last repository change: 2017-11-17T18:21:33\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 313\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 313","plain":"Stars: 313","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Bouncy Castle - http://bouncycastle.org/","descr":"Bouncy Castle is a collection of APIs used in cryptography. It includes APIs for both the Java and the C# programming languages. The APIs are supported by a registered Australian charitable organization: Legion of the Bouncy Castle Inc.","License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Description":{"plain":"The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP.","childs":{"0":["The Bouncy Castle Crypto package is a C# implementation of cryptographic algorithms and protocols, it was developed by the Legion of the Bouncy Castle, a registered Australian Charity, with a little help! The Legion, and the latest goings on with this package, can be found at http://www.bouncycastle.org. In addition to providing basic cryptography algorithms, the package also provides support for CMS, TSP, X.509 certificate generation and a variety of other standards such as OpenPGP."]}},"Repository":{"plain":"- Not Sure\n","childs":{"0":[[{"content":"Not Sure","plain":"Not Sure\n","plainChilds":"    - <https://github.com/bcgit/bc-csharp>\n    - Last repository change: 2019-09-09T17:19:15\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n- Java\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"bouncycastle","childs":{"0":["bouncycastle"]}},"CVE Product":{"plain":"legion-of-the-bouncy-castle-java-crytography-api","childs":{"0":["legion-of-the-bouncy-castle-java-crytography-api"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 638\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 638","plain":"Stars: 638","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]},{"content":"UES","plain":"UES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"ISAAC","plain":"ISAAC","plainChilds":"","childs":[]},{"content":"LEX","plain":"LEX","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"FSB","plain":"FSB","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]},{"content":"YAK","plain":"YAK","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IES","plain":"IES","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"RTD","plain":"RTD","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TSP","plain":"TSP","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"VBR","plain":"VBR","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)","plain":"- <span style=\"color:#ffe000\">Score: 5</span>: The ASN.1 parser in Bouncy Castle Crypto (aka BC Java) 1.63 can trigger a large attempted memory allocation, and resultant OutOfMemoryError error, via crafted ASN.1 data. This is fixed in 1.64. (<https://cve.circl.lu/cve/CVE-2019-17359>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later. (<https://cve.circl.lu/cve/CVE-2018-1000613>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Bouncy Castle BC 1.54 - 1.59, BC-FJA 1.0.0, BC-FJA 1.0.1 and earlier have a flaw in the Low-level interface to RSA key pair generator, specifically RSA Key Pairs generated in low-level API with added certainty may have less M-R tests than expected. This appears to be fixed in versions BC 1.60 beta 4 and later, BC-FJA 1.0.2 and later. (<https://cve.circl.lu/cve/CVE-2018-1000180>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the ECIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000352>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the other party DH public key is not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of release 1.56 the key parameters are checked on agreement calculation. (<https://cve.circl.lu/cve/CVE-2016-1000346>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding. (<https://cve.circl.lu/cve/CVE-2016-1000345>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DHIES implementation allowed the use of ECB mode. This mode is regarded as unsafe and support for it has been removed from the provider. (<https://cve.circl.lu/cve/CVE-2016-1000344>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator. (<https://cve.circl.lu/cve/CVE-2016-1000343>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000342>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier DSA signature generation is vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55, or earlier, may allow an attacker to gain information about the signature's k value and ultimately the private value as well. (<https://cve.circl.lu/cve/CVE-2016-1000341>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider versions 1.51 to 1.55, a carry propagation bug was introduced in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers. (<https://cve.circl.lu/cve/CVE-2016-1000340>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate. (<https://cve.circl.lu/cve/CVE-2016-1000339>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure. (<https://cve.circl.lu/cve/CVE-2016-1000338>)\n- <span style=\"color:#ff9c20\">Score: 7.5</span>: Bouncy Castle BKS version 1 keystore (BKS-V1) files use an HMAC that is only 16 bits long, which can allow an attacker to compromise the integrity of a BKS-V1 keystore. All BKS-V1 keystores are vulnerable. Bouncy Castle release 1.47 introduces BKS version 2, which uses a 160-bit MAC. (<https://cve.circl.lu/cve/CVE-2018-5382>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\" (<https://cve.circl.lu/cve/CVE-2017-13098>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ** DISPUTED ** The AES-GCM specification in RFC 5084, as used in Android 5.x and 6.x, recommends 12 octets for the aes-ICVlen parameter field, which might make it easier for attackers to defeat a cryptographic protection mechanism and discover an authentication key via a crafted application, aka internal bug 26234568.  NOTE: The vendor disputes the existence of this potential issue in Android, stating \"This CVE was raised in error: it referred to the authentication tag size in GCM, whose default according to ASN.1 encoding (12 bytes) can lead to vulnerabilities. After careful consideration, it was decided that the insecure default value of 12 bytes was a default only for the encoding and not default anywhere else in Android, and hence no vulnerability existed.\" (<https://cve.circl.lu/cve/CVE-2016-2427>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: The TLS implementation in the Bouncy Castle Java library before 1.48 and C# library before 1.8 does not properly consider timing side-channel attacks on a noncompliant MAC check operation during the processing of malformed CBC padding, which allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, a related issue to CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2013-1624>)\n- <span style=\"color:#ff0000\">Score: 10</span>: The Legion of the Bouncy Castle Java Cryptography API before release 1.38, as used in Crypto Provider Package before 1.36, has unknown impact and remote attack vectors related to \"a Bleichenbacher vulnerability in simple RSA CMS signatures without signed attributes.\" (<https://cve.circl.lu/cve/CVE-2007-6721>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Crypto Algorithms - https://github.com/B-Con/crypto-algorithms","descr":"Basic implementations of standard cryptography algorithms, like AES and SHA-1.","Description":{"plain":"These are basic implementations of standard cryptography algorithms, written by Brad Conte (brad@bradconte.com) from scratch and without any cross-licensing. They exist to provide publically accessible, restriction-free implementations of popular cryptographic algorithms, like AES and SHA-1. These are primarily intended for educational and pragmatic purposes (such as comparing a specification to actual implementation code, or for building an internal application that computes test vectors for a product). The algorithms have been tested against standard test vectors.","childs":{"0":["These are basic implementations of standard cryptography algorithms, written by Brad Conte (brad@bradconte.com) from scratch and without any cross-licensing. They exist to provide publically accessible, restriction-free implementations of popular cryptographic algorithms, like AES and SHA-1. These are primarily intended for educational and pragmatic purposes (such as comparing a specification to actual implementation code, or for building an internal application that computes test vectors for a product). The algorithms have been tested against standard test vectors."]}},"Repository":{"plain":"- https://github.com/B-Con/crypto-algorithms\n","childs":{"0":[[{"content":"https://github.com/B-Con/crypto-algorithms","plain":"https://github.com/B-Con/crypto-algorithms\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- Public Domain\n","childs":{"0":[[{"content":"Public Domain","plain":"Public Domain\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 830\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 830","plain":"Stars: 830","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"EST","plain":"EST","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Template - http://www.example.com","descr":"Default short description","Description":{"plain":"Default long description in __markdown__.","childs":{"0":["Default long description in __markdown__."]}},"Repository":{"plain":"- https://github.com/SitOPT/SitOPT-Installation-Script\n","childs":{"0":[[{"content":"https://github.com/SitOPT/SitOPT-Installation-Script","plain":"https://github.com/SitOPT/SitOPT-Installation-Script\n","plainChilds":"","childs":[]}]]}},"Archive":{"plain":"- https://github.com/example/example/archive/1.0.0.zip\n","childs":{"0":[[{"content":"https://github.com/example/example/archive/1.0.0.zip","plain":"https://github.com/example/example/archive/1.0.0.zip\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- MIT\n- Apache-2.0\n- MPL-2.0\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]},{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]},{"content":"MPL-2.0","plain":"MPL-2.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Release: 1.0.0\n- Release Date: Today\n","childs":{"0":[[{"content":"Release: 1.0.0","plain":"Release: 1.0.0\n","plainChilds":"","childs":[]},{"content":"Release Date: Today","plain":"Release Date: Today\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++\n- Java\n","childs":{"0":[[{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]},{"content":"Java","plain":"Java\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"template-vendor","childs":{"0":["template-vendor"]}},"CVE Product":{"plain":"template-product","childs":{"0":["template-product"]}},"Development Languages":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"OpenSSL - www.openssl.org","descr":"OpenSSL is a software library for applications that secure communications over computer networks against eavesdropping or need to identify the party at the other end. It is widely used in internet web servers, serving a majority of all web sites.","License":{"plain":"- Apache-1.0\n- BSD-4-Clause\n","childs":{"0":[[{"content":"Apache-1.0","plain":"Apache-1.0\n","plainChilds":"","childs":[]},{"content":"BSD-4-Clause","plain":"BSD-4-Clause\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/openssl/openssl>\n    - Last repository change: 2019-10-15T14:55:00\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"CVE Vendor":{"plain":"openssl","childs":{"0":["openssl"]}},"CVE Product":{"plain":"openssl","childs":{"0":["openssl"]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 11494\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 11494","plain":"Stars: 11494","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"3-Way","plain":"3-Way","plainChilds":"","childs":[]},{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"ARIA-128","plain":"ARIA-128","plainChilds":"","childs":[]},{"content":"ARIA-192","plain":"ARIA-192","plainChilds":"","childs":[]},{"content":"ARIA-256","plain":"ARIA-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CDMF","plain":"CDMF","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"FPE","plain":"FPE","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"Kuznyechik","plain":"Kuznyechik","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MMB","plain":"MMB","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Crypto1","plain":"Crypto1","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"MAG","plain":"MAG","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Turing","plain":"Turing","plainChilds":"","childs":[]},{"content":"Vernam","plain":"Vernam","plainChilds":"","childs":[]},{"content":"WAKE","plain":"WAKE","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IGE","plain":"IGE","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"PCBC","plain":"PCBC","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"OMAC","plain":"OMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]},{"content":"TMAC","plain":"TMAC","plainChilds":"","childs":[]},{"content":"VMAC","plain":"VMAC","plainChilds":"","childs":[]},{"content":"XCBC","plain":"XCBC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DVCS","plain":"DVCS","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"OpenCA","plain":"OpenCA","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMC","plain":"CMC","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PoSE","plain":"PoSE","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"","childs":{"0":[[{"content":"No Interface Languages specified","plain":"No Interface Languages specified","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1563>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). (<https://cve.circl.lu/cve/CVE-2019-1549>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1547>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1552>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j). (<https://cve.circl.lu/cve/CVE-2019-1543>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q). (<https://cve.circl.lu/cve/CVE-2019-1559>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A bug exists in the way mod_ssl handled client renegotiations. A remote attacker could send a carefully crafted request that would cause mod_ssl to enter a loop leading to a denial of service. This bug can be only triggered with Apache HTTP Server version 2.4.37 when using OpenSSL version 1.1.1 or later, due to an interaction in changes to handling of renegotiation attempts. (<https://cve.circl.lu/cve/CVE-2019-0190>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Simultaneous Multi-threading (SMT) in processors can enable local users to exploit software vulnerable to timing attacks via a side-channel timing attack on 'port contention'. (<https://cve.circl.lu/cve/CVE-2018-5407>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p). (<https://cve.circl.lu/cve/CVE-2018-0734>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1). (<https://cve.circl.lu/cve/CVE-2018-0735>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys. (<https://cve.circl.lu/cve/CVE-2016-7056>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0732>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0737>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n). (<https://cve.circl.lu/cve/CVE-2018-0739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Because of an implementation bug the PA-RISC CRYPTO_memcmp function is effectively reduced to only comparing the least significant bit of each byte. This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme. The module can only be compiled by the HP-UX assembler, so that only HP-UX PA-RISC targets are affected. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). (<https://cve.circl.lu/cve/CVE-2018-0733>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an \"error state\" mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the \"negative zero\" issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a \"DROWN\" attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a \"CacheBleed\" attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - CVE Report ist too long. [Here is a list of all CVE's](https://cve.circl.lu/search/openssl/openssl).\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1563>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). (<https://cve.circl.lu/cve/CVE-2019-1549>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1547>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1552>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j). (<https://cve.circl.lu/cve/CVE-2019-1543>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q). (<https://cve.circl.lu/cve/CVE-2019-1559>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A bug exists in the way mod_ssl handled client renegotiations. A remote attacker could send a carefully crafted request that would cause mod_ssl to enter a loop leading to a denial of service. This bug can be only triggered with Apache HTTP Server version 2.4.37 when using OpenSSL version 1.1.1 or later, due to an interaction in changes to handling of renegotiation attempts. (<https://cve.circl.lu/cve/CVE-2019-0190>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Simultaneous Multi-threading (SMT) in processors can enable local users to exploit software vulnerable to timing attacks via a side-channel timing attack on 'port contention'. (<https://cve.circl.lu/cve/CVE-2018-5407>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p). (<https://cve.circl.lu/cve/CVE-2018-0734>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1). (<https://cve.circl.lu/cve/CVE-2018-0735>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys. (<https://cve.circl.lu/cve/CVE-2016-7056>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0732>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0737>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n). (<https://cve.circl.lu/cve/CVE-2018-0739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Because of an implementation bug the PA-RISC CRYPTO_memcmp function is effectively reduced to only comparing the least significant bit of each byte. This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme. The module can only be compiled by the HP-UX assembler, so that only HP-UX PA-RISC targets are affected. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). (<https://cve.circl.lu/cve/CVE-2018-0733>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an \"error state\" mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the \"negative zero\" issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a \"DROWN\" attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a \"CacheBleed\" attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - CVE Report ist too long. [Here is a list of all CVE's](https://cve.circl.lu/search/openssl/openssl).","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1563>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). (<https://cve.circl.lu/cve/CVE-2019-1549>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Normally in OpenSSL EC groups always have a co-factor present and this is used in side channel resistant code paths. However, in some cases, it is possible to construct a group using explicit parameters (instead of using a named curve). In those cases it is possible that such a group does not have the cofactor present. This can occur even where all the parameters match a known named curve. If such a curve is used then OpenSSL falls back to non-side channel resistant code paths which may result in full key recovery during an ECDSA signature operation. In order to be vulnerable an attacker would have to have the ability to time the creation of a large number of signatures where explicit parameters with no co-factor present are in use by an application using libcrypto. For the avoidance of doubt libssl is not vulnerable because explicit parameters are never used. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1547>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: OpenSSL has internal defaults for a directory tree where it can find a configuration file as well as certificates used for verification in TLS. This directory is most commonly referred to as OPENSSLDIR, and is configurable with the --prefix / --openssldir configuration options. For OpenSSL versions 1.1.0 and 1.1.1, the mingw configuration targets assume that resulting programs and libraries are installed in a Unix-like environment and the default prefix for program installation as well as for OPENSSLDIR should be '/usr/local'. However, mingw programs are Windows programs, and as such, find themselves looking at sub-directories of 'C:/usr/local', which may be world writable, which enables untrusted users to modify OpenSSL's default configuration, insert CA certificates, modify (or even replace) existing engine modules, etc. For OpenSSL 1.0.2, '/usr/local/ssl' is used as default for OPENSSLDIR on all Unix and Windows targets, including Visual C builds. However, some build instructions for the diverse Windows targets on 1.0.2 encourage you to specify your own --prefix. OpenSSL versions 1.1.1, 1.1.0 and 1.0.2 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s). (<https://cve.circl.lu/cve/CVE-2019-1552>)\n- <span style=\"color:#ffcc00\">Score: 5.8</span>: ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j). (<https://cve.circl.lu/cve/CVE-2019-1543>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable \"non-stitched\" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q). (<https://cve.circl.lu/cve/CVE-2019-1559>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A bug exists in the way mod_ssl handled client renegotiations. A remote attacker could send a carefully crafted request that would cause mod_ssl to enter a loop leading to a denial of service. This bug can be only triggered with Apache HTTP Server version 2.4.37 when using OpenSSL version 1.1.1 or later, due to an interaction in changes to handling of renegotiation attempts. (<https://cve.circl.lu/cve/CVE-2019-0190>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Simultaneous Multi-threading (SMT) in processors can enable local users to exploit software vulnerable to timing attacks via a side-channel timing attack on 'port contention'. (<https://cve.circl.lu/cve/CVE-2018-5407>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p). (<https://cve.circl.lu/cve/CVE-2018-0734>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL ECDSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.1.1a (Affected 1.1.1). (<https://cve.circl.lu/cve/CVE-2018-0735>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys. (<https://cve.circl.lu/cve/CVE-2016-7056>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0732>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o). (<https://cve.circl.lu/cve/CVE-2018-0737>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Constructed ASN.1 types with a recursive definition (such as can be found in PKCS7) could eventually exceed the stack given malicious input with excessive recursion. This could result in a Denial Of Service attack. There are no such structures used within SSL/TLS that come from untrusted sources so this is considered safe. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). Fixed in OpenSSL 1.0.2o (Affected 1.0.2b-1.0.2n). (<https://cve.circl.lu/cve/CVE-2018-0739>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Because of an implementation bug the PA-RISC CRYPTO_memcmp function is effectively reduced to only comparing the least significant bit of each byte. This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme. The module can only be compiled by the HP-UX assembler, so that only HP-UX PA-RISC targets are affected. Fixed in OpenSSL 1.1.0h (Affected 1.1.0-1.1.0g). (<https://cve.circl.lu/cve/CVE-2018-0733>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is an overflow bug in the AVX2 Montgomery multiplication procedure used in exponentiation with 1024-bit moduli. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH1024 are considered just feasible, because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be significant. However, for an attack on TLS to be meaningful, the server would have to share the DH1024 private key among multiple clients, which is no longer an option since CVE-2016-0701. This only affects processors that support the AVX2 but not ADX extensions like Intel Haswell (4th generation). Note: The impact from this issue is similar to CVE-2017-3736, CVE-2017-3732 and CVE-2015-3193. OpenSSL version 1.0.2-1.0.2m and 1.1.0-1.1.0g are affected. Fixed in OpenSSL 1.0.2n. Due to the low severity of this issue we are not issuing a new release of OpenSSL 1.1.0 at this time. The fix will be included in OpenSSL 1.1.0h when it becomes available. The fix is also available in commit e502cc86d in the OpenSSL git repository. (<https://cve.circl.lu/cve/CVE-2017-3738>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: OpenSSL 1.0.2 (starting from version 1.0.2b) introduced an \"error state\" mechanism. The intent was that if a fatal error occurred during a handshake then OpenSSL would move into the error state and would immediately fail if you attempted to continue the handshake. This works as designed for the explicit handshake functions (SSL_do_handshake(), SSL_accept() and SSL_connect()), however due to a bug it does not work correctly if SSL_read() or SSL_write() is called directly. In that scenario, if the handshake fails then a fatal error will be returned in the initial function call. If SSL_read()/SSL_write() is subsequently called by the application for the same SSL object then it will succeed and the data is passed without being decrypted/encrypted directly from the SSL/TLS record layer. In order to exploit this issue an application bug would have to be present that resulted in a call to SSL_read()/SSL_write() being issued after having already received a fatal error. OpenSSL version 1.0.2b-1.0.2m are affected. Fixed in OpenSSL 1.0.2n. OpenSSL 1.1.0 is not affected. (<https://cve.circl.lu/cve/CVE-2017-3737>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: A denial of service flaw was found in OpenSSL 0.9.8, 1.0.1, 1.0.2 through 1.0.2h, and 1.1.0 in the way the TLS/SSL protocol defined processing of ALERT packets during a connection handshake. A remote attacker could use this flaw to make a TLS/SSL server consume an excessive amount of CPU and fail to accept connections from other clients. (<https://cve.circl.lu/cve/CVE-2016-8610>)\n- <span style=\"color:#d1ff00\">Score: 4.0</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL before 1.0.2m and 1.1.0 before 1.1.0g. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. This only affects processors that support the BMI1, BMI2 and ADX extensions like Intel Broadwell (5th generation) and later or AMD Ryzen. (<https://cve.circl.lu/cve/CVE-2017-3736>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g. (<https://cve.circl.lu/cve/CVE-2017-3735>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected. (<https://cve.circl.lu/cve/CVE-2017-3733>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The doapr_outch function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not verify that a certain memory allocation succeeds, which allows remote attackers to cause a denial of service (out-of-bounds write or memory consumption) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-0799. (<https://cve.circl.lu/cve/CVE-2016-2842>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The DES and Triple DES ciphers, as used in the TLS, SSH, and IPSec protocols and other protocols and products, have a birthday bound of approximately four billion blocks, which makes it easier for remote attackers to obtain cleartext data via a birthday attack against a long-duration encrypted session, as demonstrated by an HTTPS session using Triple DES in CBC mode, aka a \"Sweet32\" attack. (<https://cve.circl.lu/cve/CVE-2016-2183>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the \"negative zero\" issue. (<https://cve.circl.lu/cve/CVE-2016-2108>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The AES-NI implementation in OpenSSL before 1.0.1t and 1.0.2 before 1.0.2h does not consider memory allocation during a certain padding check, which allows remote attackers to obtain sensitive cleartext information via a padding-oracle attack against an AES CBC session. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-0169. (<https://cve.circl.lu/cve/CVE-2016-2107>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The SSLv2 protocol, as used in OpenSSL before 1.0.1s and 1.0.2 before 1.0.2g and other products, requires a server to send a ServerVerify message before establishing that a client possesses certain plaintext RSA data, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, aka a \"DROWN\" attack. (<https://cve.circl.lu/cve/CVE-2016-0800>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: The fmtstr function in crypto/bio/b_print.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g improperly calculates string lengths, which allows remote attackers to cause a denial of service (overflow and out-of-bounds read) or possibly have unspecified other impact via a long string, as demonstrated by a large amount of ASN.1 data, a different vulnerability than CVE-2016-2842. (<https://cve.circl.lu/cve/CVE-2016-0799>)\n- <span style=\"color:#ff9c20\">Score: 7.8</span>: Memory leak in the SRP_VBASE_get_by_user implementation in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory consumption) by providing an invalid username in a connection attempt, related to apps/s_server.c and crypto/srp/srp_vfy.c. (<https://cve.circl.lu/cve/CVE-2016-0798>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Multiple integer overflows in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allow remote attackers to cause a denial of service (heap memory corruption or NULL pointer dereference) or possibly have unspecified other impact via a long digit string that is mishandled by the (1) BN_dec2bn or (2) BN_hex2bn function, related to crypto/bn/bn.h and crypto/bn/bn_print.c. (<https://cve.circl.lu/cve/CVE-2016-0797>)\n- <span style=\"color:#ff0000\">Score: 10.0</span>: Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key. (<https://cve.circl.lu/cve/CVE-2016-0705>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: An oracle protection mechanism in the get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a overwrites incorrect MASTER-KEY bytes during use of export cipher suites, which makes it easier for remote attackers to decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0704>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: The get_client_master_key function in s2_srvr.c in the SSLv2 implementation in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a accepts a nonzero CLIENT-MASTER-KEY CLEAR-KEY-LENGTH value for an arbitrary cipher, which allows man-in-the-middle attackers to determine the MASTER-KEY value and decrypt TLS ciphertext data by leveraging a Bleichenbacher RSA padding oracle, a related issue to CVE-2016-0800. (<https://cve.circl.lu/cve/CVE-2016-0703>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a \"CacheBleed\" attack. (<https://cve.circl.lu/cve/CVE-2016-0702>)\n- <span style=\"color:#00f000\">Score: 2.6</span>: The DH_check_pub_key function in crypto/dh/dh_check.c in OpenSSL 1.0.2 before 1.0.2f does not ensure that prime numbers are appropriate for Diffie-Hellman (DH) key exchange, which makes it easier for remote attackers to discover a private DH exponent by making multiple handshakes with a peer that chose an inappropriate number, as demonstrated by a number in an X9.42 file. (<https://cve.circl.lu/cve/CVE-2016-0701>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s2_srvr.c in OpenSSL 1.0.1 before 1.0.1r and 1.0.2 before 1.0.2f does not prevent use of disabled ciphers, which makes it easier for man-in-the-middle attackers to defeat cryptographic protection mechanisms by performing computations on SSLv2 traffic, related to the get_client_master_key and get_client_hello functions. (<https://cve.circl.lu/cve/CVE-2015-3197>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: ssl/s3_clnt.c in OpenSSL 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1p, and 1.0.2 before 1.0.2d, when used for a multi-threaded client, writes the PSK identity hint to an incorrect data structure, which allows remote servers to cause a denial of service (race condition and double free) via a crafted ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-3196>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application. (<https://cve.circl.lu/cve/CVE-2015-3195>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: crypto/rsa/rsa_ameth.c in OpenSSL 1.0.1 before 1.0.1q and 1.0.2 before 1.0.2e allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via an RSA PSS ASN.1 signature that lacks a mask generation function parameter. (<https://cve.circl.lu/cve/CVE-2015-3194>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The Montgomery squaring implementation in crypto/bn/asm/x86_64-mont5.pl in OpenSSL 1.0.2 before 1.0.2e on the x86_64 platform, as used by the BN_mod_exp function, mishandles carry propagation and produces incorrect output, which makes it easier for remote attackers to obtain sensitive private-key information via an attack against use of a (1) Diffie-Hellman (DH) or (2) Diffie-Hellman Ephemeral (DHE) ciphersuite. (<https://cve.circl.lu/cve/CVE-2015-3193>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The ssl3_get_key_exchange function in ssl/s3_clnt.c in OpenSSL 1.0.2 before 1.0.2e allows remote servers to cause a denial of service (segmentation fault) via a zero p value in an anonymous Diffie-Hellman (DH) ServerKeyExchange message. (<https://cve.circl.lu/cve/CVE-2015-1794>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: There is a carry propagating bug in the x86_64 Montgomery squaring procedure in OpenSSL 1.0.2 before 1.0.2k and 1.1.0 before 1.1.0d. No EC algorithms are affected. Analysis suggests that attacks against RSA and DSA as a result of this defect would be very difficult to perform and are not believed likely. Attacks against DH are considered just feasible (although very difficult) because most of the work necessary to deduce information about a private key may be performed offline. The amount of resources required for such an attack would be very significant and likely only accessible to a limited number of attackers. An attacker would additionally need online access to an unpatched system using the target private key in a scenario with persistent DH parameters and a private key that is shared between multiple clients. For example this can occur by default in OpenSSL DHE based SSL/TLS ciphersuites. Note: This issue is very similar to CVE-2015-3193 but must be treated as a separate problem. (<https://cve.circl.lu/cve/CVE-2017-3732>)\n - CVE Report ist too long. [Here is a list of all CVE's](https://cve.circl.lu/search/openssl/openssl).\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Libgcrypt - https://gnupg.org/software/libgcrypt/","descr":"Libgcrypt is a general purpose cryptographic library originally based on code from GnuPG.","Description":{"plain":"Libgcrypt is a cryptography library developed as a separated module of GnuPG. It can also be used independently of GnuPG, but depends on its error-reporting library Libgpg-error.","childs":{"0":["Libgcrypt is a cryptography library developed as a separated module of GnuPG. It can also be used independently of GnuPG, but depends on its error-reporting library Libgpg-error."]}},"Repository":{"plain":"- https://dev.gnupg.org/source/libgcrypt.git\n","childs":{"0":[[{"content":"https://dev.gnupg.org/source/libgcrypt.git","plain":"https://dev.gnupg.org/source/libgcrypt.git\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- GNU Lesser General Public License\n- GNU General Public License\n","childs":{"0":[[{"content":"GNU Lesser General Public License","plain":"GNU Lesser General Public License\n","plainChilds":"","childs":[]},{"content":"GNU General Public License","plain":"GNU General Public License\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Developers: Werner Koch\n- The information is applicable to the latest commit in the repository, not a specific release!\n","childs":{"0":[[{"content":"Developers: Werner Koch","plain":"Developers: Werner Koch\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"gnupg","childs":{"0":["gnupg"]}},"CVE Product":{"plain":"libgcrypt","childs":{"0":["libgcrypt"]}},"Development Languages":{"plain":"- C\n- C++\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SHAKE","plain":"SHAKE","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"CBC-MAC","plain":"CBC-MAC","plainChilds":"","childs":[]},{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"","childs":{"0":[[{"content":"No Interface Languages specified","plain":"No Interface Languages specified","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) (<https://cve.circl.lu/cve/CVE-2019-12904>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used. (<https://cve.circl.lu/cve/CVE-2017-7526>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-0495>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation. (<https://cve.circl.lu/cve/CVE-2018-6829>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c. (<https://cve.circl.lu/cve/CVE-2017-0379>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt before 1.7.7, an attacker who learns the EdDSA session key (from side-channel observation during the signing process) can easily recover the long-term secret key. 1.7.7 makes a cipher/ecc-eddsa.c change to store this session key in secure memory, to ensure that constant-time point operations are used in the MPI library. (<https://cve.circl.lu/cve/CVE-2017-9526>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The mixing functions in the random number generator in Libgcrypt before 1.5.6, 1.6.x before 1.6.6, and 1.7.x before 1.7.3 and GnuPG before 1.4.21 make it easier for attackers to obtain the values of 160 bits by leveraging knowledge of the previous 4640 bits. (<https://cve.circl.lu/cve/CVE-2016-6313>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: GnuPG before 1.4.14, and Libgcrypt before 1.5.3 as used in GnuPG 2.0.x and possibly other products, allows local users to obtain private RSA keys via a cache side-channel attack involving the L3 cache, aka Flush+Reload. (<https://cve.circl.lu/cve/CVE-2013-4242>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.6.5 does not properly perform elliptic-point curve multiplication during decryption, which makes it easier for physically proximate attackers to extract ECDH keys by measuring electromagnetic emanations. (<https://cve.circl.lu/cve/CVE-2015-7511>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: Libgcrypt before 1.5.4, as used in GnuPG and other products, does not properly perform ciphertext normalization and ciphertext randomization, which makes it easier for physically proximate attackers to conduct key-extraction attacks by leveraging the ability to collect voltage data from exposed metal, a different vector than CVE-2013-4576. (<https://cve.circl.lu/cve/CVE-2014-5270>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) (<https://cve.circl.lu/cve/CVE-2019-12904>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used. (<https://cve.circl.lu/cve/CVE-2017-7526>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-0495>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation. (<https://cve.circl.lu/cve/CVE-2018-6829>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c. (<https://cve.circl.lu/cve/CVE-2017-0379>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt before 1.7.7, an attacker who learns the EdDSA session key (from side-channel observation during the signing process) can easily recover the long-term secret key. 1.7.7 makes a cipher/ecc-eddsa.c change to store this session key in secure memory, to ensure that constant-time point operations are used in the MPI library. (<https://cve.circl.lu/cve/CVE-2017-9526>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The mixing functions in the random number generator in Libgcrypt before 1.5.6, 1.6.x before 1.6.6, and 1.7.x before 1.7.3 and GnuPG before 1.4.21 make it easier for attackers to obtain the values of 160 bits by leveraging knowledge of the previous 4640 bits. (<https://cve.circl.lu/cve/CVE-2016-6313>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: GnuPG before 1.4.14, and Libgcrypt before 1.5.3 as used in GnuPG 2.0.x and possibly other products, allows local users to obtain private RSA keys via a cache side-channel attack involving the L3 cache, aka Flush+Reload. (<https://cve.circl.lu/cve/CVE-2013-4242>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.6.5 does not properly perform elliptic-point curve multiplication during decryption, which makes it easier for physically proximate attackers to extract ECDH keys by measuring electromagnetic emanations. (<https://cve.circl.lu/cve/CVE-2015-7511>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: Libgcrypt before 1.5.4, as used in GnuPG and other products, does not properly perform ciphertext normalization and ciphertext randomization, which makes it easier for physically proximate attackers to conduct key-extraction attacks by leveraging the ability to collect voltage data from exposed metal, a different vector than CVE-2013-4576. (<https://cve.circl.lu/cve/CVE-2014-5270>)","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) (<https://cve.circl.lu/cve/CVE-2019-12904>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: libgcrypt before version 1.7.8 is vulnerable to a cache side-channel attack resulting into a complete break of RSA-1024 while using the left-to-right method for computing the sliding-window expansion. The same attack is believed to work on RSA-2048 with moderately more computation. This side-channel requires that attacker can run arbitrary software on the hardware where the private RSA key is used. (<https://cve.circl.lu/cve/CVE-2017-7526>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: The Elliptic Curve Cryptography library (aka sunec or libsunec) allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12438>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: LibTomCrypt through 1.18.1 allows a memory-cache side-channel attack on ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-12437>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: ** DISPUTED ** cryptlib through 3.4.4 allows a memory-cache side-channel attack on DSA and ECDSA signatures, aka the Return Of the Hidden Number Problem or ROHNP. To discover a key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. NOTE: the vendor does not include side-channel attacks within its threat model. (<https://cve.circl.lu/cve/CVE-2018-12433>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host. (<https://cve.circl.lu/cve/CVE-2018-0495>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: cipher/elgamal.c in Libgcrypt through 1.8.2, when used to encrypt messages directly, improperly encodes plaintexts, which allows attackers to obtain sensitive information by reading ciphertext data (i.e., it does not have semantic security in face of a ciphertext-only attack). The Decisional Diffie-Hellman (DDH) assumption does not hold for Libgcrypt's ElGamal implementation. (<https://cve.circl.lu/cve/CVE-2018-6829>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c. (<https://cve.circl.lu/cve/CVE-2017-0379>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: In Libgcrypt before 1.7.7, an attacker who learns the EdDSA session key (from side-channel observation during the signing process) can easily recover the long-term secret key. 1.7.7 makes a cipher/ecc-eddsa.c change to store this session key in secure memory, to ensure that constant-time point operations are used in the MPI library. (<https://cve.circl.lu/cve/CVE-2017-9526>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The mixing functions in the random number generator in Libgcrypt before 1.5.6, 1.6.x before 1.6.6, and 1.7.x before 1.7.3 and GnuPG before 1.4.21 make it easier for attackers to obtain the values of 160 bits by leveraging knowledge of the previous 4640 bits. (<https://cve.circl.lu/cve/CVE-2016-6313>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: GnuPG before 1.4.14, and Libgcrypt before 1.5.3 as used in GnuPG 2.0.x and possibly other products, allows local users to obtain private RSA keys via a cache side-channel attack involving the L3 cache, aka Flush+Reload. (<https://cve.circl.lu/cve/CVE-2013-4242>)\n- <span style=\"color:#00e020\">Score: 1.9</span>: Libgcrypt before 1.6.5 does not properly perform elliptic-point curve multiplication during decryption, which makes it easier for physically proximate attackers to extract ECDH keys by measuring electromagnetic emanations. (<https://cve.circl.lu/cve/CVE-2015-7511>)\n- <span style=\"color:#00f000\">Score: 2.1</span>: Libgcrypt before 1.5.4, as used in GnuPG and other products, does not properly perform ciphertext normalization and ciphertext randomization, which makes it easier for physically proximate attackers to conduct key-extraction attacks by leveraging the ability to collect voltage data from exposed metal, a different vector than CVE-2013-4576. (<https://cve.circl.lu/cve/CVE-2014-5270>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"CryptoPP - http://www.cryptopp.com/","descr":"Free C++ class library of cryptographic schemes","Description":{"plain":"Crypto++ (also known as CryptoPP, libcrypto++, and libcryptopp) is a free and open source C++ class library of cryptographic algorithms and schemes written by Wei Dai. Crypto++ has been widely used in academia, student projects, open source and non-commercial projects, as well as businesses.[1] Released in 1995, the library fully supports 32-bit and 64-bit architectures for many major operating systems and platforms, including Android (using STLport), Apple (Mac OS X and iOS), BSD, Cygwin, IBM AIX and S/390, Linux, MinGW, Solaris, Windows, Windows Phone and Windows RT. The project also supports compilation using C++03, C++11 and C++17 runtime libraries; and a variety of compilers and IDEs, including Borland Turbo C++, Borland C++ Builder, Clang, CodeWarrior Pro, GCC (including Apple's GCC), Intel C++ Compiler (ICC), Microsoft Visual C/C++, and Sun Studio.","childs":{"0":["Crypto++ (also known as CryptoPP, libcrypto++, and libcryptopp) is a free and open source C++ class library of cryptographic algorithms and schemes written by Wei Dai. Crypto++ has been widely used in academia, student projects, open source and non-commercial projects, as well as businesses.[1] Released in 1995, the library fully supports 32-bit and 64-bit architectures for many major operating systems and platforms, including Android (using STLport), Apple (Mac OS X and iOS), BSD, Cygwin, IBM AIX and S/390, Linux, MinGW, Solaris, Windows, Windows Phone and Windows RT. The project also supports compilation using C++03, C++11 and C++17 runtime libraries; and a variety of compilers and IDEs, including Borland Turbo C++, Borland C++ Builder, Clang, CodeWarrior Pro, GCC (including Apple's GCC), Intel C++ Compiler (ICC), Microsoft Visual C/C++, and Sun Studio."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/weidai11/cryptopp>\n    - Last repository change: 2019-10-16T11:42:48\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Boost Software License 1.0\n","childs":{"0":[[{"content":"Boost Software License 1.0","plain":"Boost Software License 1.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Initial release: 1995\n- Developers: originally Wei Dai, the Crypto++ project since 2015\n- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 1956\n","childs":{"0":[[{"content":"Initial release: 1995","plain":"Initial release: 1995\n","plainChilds":"","childs":[]},{"content":"Developers: originally Wei Dai, the Crypto++ project since 2015","plain":"Developers: originally Wei Dai, the Crypto++ project since 2015\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 1956","plain":"Stars: 1956","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C++\n","childs":{"0":[[{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"cryptopp","childs":{"0":["cryptopp"]}},"CVE Product":{"plain":"crypto++","childs":{"0":["crypto++"]}},"Development Languages":{"plain":"- C++\n","childs":{"0":[[{"content":"C++","plain":"C++","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"Blowfish","plain":"Blowfish","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CAST-128","plain":"CAST-128","plainChilds":"","childs":[]},{"content":"CAST-256","plain":"CAST-256","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"Kalyna","plain":"Kalyna","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MARS","plain":"MARS","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"NOEKEON","plain":"NOEKEON","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"RC5","plain":"RC5","plainChilds":"","childs":[]},{"content":"RC6","plain":"RC6","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"Serpent","plain":"Serpent","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"SHACAL","plain":"SHACAL","plainChilds":"","childs":[]},{"content":"SHARK","plain":"SHARK","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"Skipjack","plain":"Skipjack","plainChilds":"","childs":[]},{"content":"SM4","plain":"SM4","plainChilds":"","childs":[]},{"content":"Speck","plain":"Speck","plainChilds":"","childs":[]},{"content":"Threefish","plain":"Threefish","plainChilds":"","childs":[]},{"content":"TEA","plain":"TEA","plainChilds":"","childs":[]},{"content":"Twofish","plain":"Twofish","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"eSTREAM","plain":"eSTREAM","plainChilds":"","childs":[]},{"content":"HC-256","plain":"HC-256","plainChilds":"","childs":[]},{"content":"HC-128","plain":"HC-128","plainChilds":"","childs":[]},{"content":"Panama","plain":"Panama","plainChilds":"","childs":[]},{"content":"Pike","plain":"Pike","plainChilds":"","childs":[]},{"content":"Rabbit","plain":"Rabbit","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]},{"content":"Sosemanuk","plain":"Sosemanuk","plainChilds":"","childs":[]},{"content":"WAKE","plain":"WAKE","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"RIPEMD","plain":"RIPEMD","plainChilds":"","childs":[]},{"content":"scrypt","plain":"scrypt","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"SipHash","plain":"SipHash","plainChilds":"","childs":[]},{"content":"Skein","plain":"Skein","plainChilds":"","childs":[]},{"content":"Tiger","plain":"Tiger","plainChilds":"","childs":[]},{"content":"WHIRLPOOL","plain":"WHIRLPOOL","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]},{"content":"VMAC","plain":"VMAC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"ElGamal","plain":"ElGamal","plainChilds":"","childs":[]},{"content":"LUC","plain":"LUC","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AS1","plain":"AS1","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ 8.3.0 and earlier contains a timing side channel in ECDSA signature generation. This allows a local or remote attacker, able to measure the duration of hundreds to thousands of signing operations, to compute the private key used. The issue occurs because scalar multiplication in ecp.cpp (prime field curves, small leakage) and algebra.cpp (binary field curves, large leakage) is not constant time and leaks the bit length of the scalar among other information. (<https://cve.circl.lu/cve/CVE-2019-14318>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp) through 5.6.5 contains an out-of-bounds read vulnerability in zinflate.cpp in the Inflator filter. (<https://cve.circl.lu/cve/CVE-2017-9434>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The timing attack protection in Rijndael::Enc::ProcessAndXorBlock and Rijndael::Dec::ProcessAndXorBlock in Crypto++ (aka cryptopp) before 5.6.4 may be optimized out by the compiler, which allows attackers to conduct timing attacks. (<https://cve.circl.lu/cve/CVE-2016-3995>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp and libcrypto++) 5.6.4 contained a bug in its ASN.1 BER decoding routine. The library will allocate a memory block based on the length field of the ASN.1 object. If there is not enough content octets in the ASN.1 object, then the function will fail and the memory block will be zeroed even if its unused. There is a noticeable delay during the wipe for a large allocation. (<https://cve.circl.lu/cve/CVE-2016-9939>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Crypto++ 5.6.4 incorrectly uses Microsoft's stack-based _malloca and _freea functions. The library will request a block of memory to align a table in memory. If the table is later reallocated, then the wrong pointer could be freed. (<https://cve.circl.lu/cve/CVE-2016-7544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ (aka cryptopp) through 5.6.4 does not document the requirement for a compile-time NDEBUG definition disabling the many assert calls that are unintended in production use, which might allow context-dependent attackers to obtain sensitive information by leveraging access to process memory after an assertion failure, as demonstrated by reading a core dump. (<https://cve.circl.lu/cve/CVE-2016-7420>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack. (<https://cve.circl.lu/cve/CVE-2015-2141>)\u0000","childs":{"0":[[{"content":"- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ 8.3.0 and earlier contains a timing side channel in ECDSA signature generation. This allows a local or remote attacker, able to measure the duration of hundreds to thousands of signing operations, to compute the private key used. The issue occurs because scalar multiplication in ecp.cpp (prime field curves, small leakage) and algebra.cpp (binary field curves, large leakage) is not constant time and leaks the bit length of the scalar among other information. (<https://cve.circl.lu/cve/CVE-2019-14318>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp) through 5.6.5 contains an out-of-bounds read vulnerability in zinflate.cpp in the Inflator filter. (<https://cve.circl.lu/cve/CVE-2017-9434>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The timing attack protection in Rijndael::Enc::ProcessAndXorBlock and Rijndael::Dec::ProcessAndXorBlock in Crypto++ (aka cryptopp) before 5.6.4 may be optimized out by the compiler, which allows attackers to conduct timing attacks. (<https://cve.circl.lu/cve/CVE-2016-3995>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp and libcrypto++) 5.6.4 contained a bug in its ASN.1 BER decoding routine. The library will allocate a memory block based on the length field of the ASN.1 object. If there is not enough content octets in the ASN.1 object, then the function will fail and the memory block will be zeroed even if its unused. There is a noticeable delay during the wipe for a large allocation. (<https://cve.circl.lu/cve/CVE-2016-9939>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Crypto++ 5.6.4 incorrectly uses Microsoft's stack-based _malloca and _freea functions. The library will request a block of memory to align a table in memory. If the table is later reallocated, then the wrong pointer could be freed. (<https://cve.circl.lu/cve/CVE-2016-7544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ (aka cryptopp) through 5.6.4 does not document the requirement for a compile-time NDEBUG definition disabling the many assert calls that are unintended in production use, which might allow context-dependent attackers to obtain sensitive information by leveraging access to process memory after an assertion failure, as demonstrated by reading a core dump. (<https://cve.circl.lu/cve/CVE-2016-7420>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack. (<https://cve.circl.lu/cve/CVE-2015-2141>)","plain":"- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ 8.3.0 and earlier contains a timing side channel in ECDSA signature generation. This allows a local or remote attacker, able to measure the duration of hundreds to thousands of signing operations, to compute the private key used. The issue occurs because scalar multiplication in ecp.cpp (prime field curves, small leakage) and algebra.cpp (binary field curves, large leakage) is not constant time and leaks the bit length of the scalar among other information. (<https://cve.circl.lu/cve/CVE-2019-14318>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp) through 5.6.5 contains an out-of-bounds read vulnerability in zinflate.cpp in the Inflator filter. (<https://cve.circl.lu/cve/CVE-2017-9434>)\n- <span style=\"color:#ffe000\">Score: 5</span>: The timing attack protection in Rijndael::Enc::ProcessAndXorBlock and Rijndael::Dec::ProcessAndXorBlock in Crypto++ (aka cryptopp) before 5.6.4 may be optimized out by the compiler, which allows attackers to conduct timing attacks. (<https://cve.circl.lu/cve/CVE-2016-3995>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: Crypto++ (aka cryptopp and libcrypto++) 5.6.4 contained a bug in its ASN.1 BER decoding routine. The library will allocate a memory block based on the length field of the ASN.1 object. If there is not enough content octets in the ASN.1 object, then the function will fail and the memory block will be zeroed even if its unused. There is a noticeable delay during the wipe for a large allocation. (<https://cve.circl.lu/cve/CVE-2016-9939>)\n- <span style=\"color:#ffe000\">Score: 5</span>: Crypto++ 5.6.4 incorrectly uses Microsoft's stack-based _malloca and _freea functions. The library will request a block of memory to align a table in memory. If the table is later reallocated, then the wrong pointer could be freed. (<https://cve.circl.lu/cve/CVE-2016-7544>)\n- <span style=\"color:#ffe000\">Score: 4.3</span>: Crypto++ (aka cryptopp) through 5.6.4 does not document the requirement for a compile-time NDEBUG definition disabling the many assert calls that are unintended in production use, which might allow context-dependent attackers to obtain sensitive information by leveraging access to process memory after an assertion failure, as demonstrated by reading a core dump. (<https://cve.circl.lu/cve/CVE-2016-7420>)\n- <span style=\"color:#ffe000\">Score: 5.0</span>: The InvertibleRWFunction::CalculateInverse function in rw.cpp in libcrypt++ 5.6.2 does not properly blind private key operations for the Rabin-Williams digital signature algorithm, which allows remote attackers to obtain private keys via a timing attack. (<https://cve.circl.lu/cve/CVE-2015-2141>)\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"SecurityDriven.Inferno - http://securitydriven.net/inferno/","descr":".NET crypto done right. Professionally audited.","Description":{"plain":"Inferno has the following design goals:\n\n- .NET crypto done right.\n- Free, open source (MIT license).\n- Developer-friendly, misuse-resistant API.\n- Safe by design: safe algorithms, safe modes, safe choices.\n- Does not re-implement crypto primitives.\n- Uses FIPS-certified implementations where possible.\n- 100% managed modern c# 6.0. The only reference is \"System.dll\".\n- Performance-oriented (within reason - unsafe code is not a reason).\n- Minimal codebase, high maintainability & introspectability (easy security audits).\n- Unit testing, fuzz testing.\n- Streaming authenticated encryption (secure channels).\n- Symmetric crypto: AEAD only.\n- Asymmetric crypto: NSA/CNSA Suite B API only (Elliptic Curves). No RSA.\n- Decent documentation & code examples.\n","childs":{"0":["Inferno has the following design goals:",[{"content":".NET crypto done right.","plain":".NET crypto done right.\n","plainChilds":"","childs":[]},{"content":"Free, open source (MIT license).","plain":"Free, open source (MIT license).\n","plainChilds":"","childs":[]},{"content":"Developer-friendly, misuse-resistant API.","plain":"Developer-friendly, misuse-resistant API.\n","plainChilds":"","childs":[]},{"content":"Safe by design: safe algorithms, safe modes, safe choices.","plain":"Safe by design: safe algorithms, safe modes, safe choices.\n","plainChilds":"","childs":[]},{"content":"Does not re-implement crypto primitives.","plain":"Does not re-implement crypto primitives.\n","plainChilds":"","childs":[]},{"content":"Uses FIPS-certified implementations where possible.","plain":"Uses FIPS-certified implementations where possible.\n","plainChilds":"","childs":[]},{"content":"100% managed modern c# 6.0. The only reference is \"System.dll\".","plain":"100% managed modern c# 6.0. The only reference is \"System.dll\".\n","plainChilds":"","childs":[]},{"content":"Performance-oriented (within reason - unsafe code is not a reason).","plain":"Performance-oriented (within reason - unsafe code is not a reason).\n","plainChilds":"","childs":[]},{"content":"Minimal codebase, high maintainability & introspectability (easy security audits).","plain":"Minimal codebase, high maintainability & introspectability (easy security audits).\n","plainChilds":"","childs":[]},{"content":"Unit testing, fuzz testing.","plain":"Unit testing, fuzz testing.\n","plainChilds":"","childs":[]},{"content":"Streaming authenticated encryption (secure channels).","plain":"Streaming authenticated encryption (secure channels).\n","plainChilds":"","childs":[]},{"content":"Symmetric crypto: AEAD only.","plain":"Symmetric crypto: AEAD only.\n","plainChilds":"","childs":[]},{"content":"Asymmetric crypto: NSA/CNSA Suite B API only (Elliptic Curves). No RSA.","plain":"Asymmetric crypto: NSA/CNSA Suite B API only (Elliptic Curves). No RSA.\n","plainChilds":"","childs":[]},{"content":"Decent documentation & code examples.","plain":"Decent documentation & code examples.\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"- Not Sure\n","childs":{"0":[[{"content":"Not Sure","plain":"Not Sure\n","plainChilds":"    - <https://github.com/sdrapkin/SecurityDriven.Inferno>\n    - Last repository change: 2019-06-05T13:31:46\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- MIT\n","childs":{"0":[[{"content":"MIT","plain":"MIT\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 440\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 440","plain":"Stars: 440","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C#\n","childs":{"0":[[{"content":"C#","plain":"C#","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"GnuTLS - https://gnutls.org/","descr":"GnuTLS is a secure communications library implementing the SSL, TLS and DTLS protocols and technologies around them. It provides a simple C language API to access the secure communications protocols. ","Description":{"plain":"GnuTLS (the GNU Transport Layer Security Library) is a free software implementation of the TLS, SSL and DTLS protocols. It offers an application programming interface (API) for applications to enable secure communication over the network transport layer, as well as interfaces to access X.509, PKCS #12, OpenPGP and other structures.","childs":{"0":["GnuTLS (the GNU Transport Layer Security Library) is a free software implementation of the TLS, SSL and DTLS protocols. It offers an application programming interface (API) for applications to enable secure communication over the network transport layer, as well as interfaces to access X.509, PKCS #12, OpenPGP and other structures."]}},"Repository":{"plain":"- https://gitlab.com/gnutls/gnutls\n","childs":{"0":[[{"content":"https://gitlab.com/gnutls/gnutls","plain":"https://gitlab.com/gnutls/gnutls\n","plainChilds":"","childs":[]}]]}},"License":{"plain":"- LGPLv2.1+\n","childs":{"0":[[{"content":"LGPLv2.1+","plain":"LGPLv2.1+\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Developers: Nikos Mavrogiannopoulos, Simon Josefsson\n- The information is applicable to the latest commit in the repository, not a specific release!\n","childs":{"0":[[{"content":"Developers: Nikos Mavrogiannopoulos, Simon Josefsson","plain":"Developers: Nikos Mavrogiannopoulos, Simon Josefsson\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C\n","childs":{"0":[[{"content":"C","plain":"C\n","plainChilds":"","childs":[]}]]}},"CVE Vendor":{"plain":"gnu","childs":{"0":["gnu"]}},"CVE Product":{"plain":"gnutls","childs":{"0":["gnutls"]}},"Development Languages":{"plain":"- C\n- C++\n- JavaScript\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"JavaScript","plain":"JavaScript","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"Camellia","plain":"Camellia","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"CS-Cipher","plain":"CS-Cipher","plainChilds":"","childs":[]},{"content":"DES","plain":"DES","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"IDEA NXT","plain":"IDEA NXT","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MESH","plain":"MESH","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"RC2","plain":"RC2","plainChilds":"","childs":[]},{"content":"SAFER","plain":"SAFER","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]},{"content":"Simon","plain":"Simon","plainChilds":"","childs":[]},{"content":"3DES","plain":"3DES","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Dragon","plain":"Dragon","plainChilds":"","childs":[]},{"content":"NLS","plain":"NLS","plainChilds":"","childs":[]},{"content":"RC","plain":"RC","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"GOST","plain":"GOST","plainChilds":"","childs":[]},{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]},{"content":"Streebog","plain":"Streebog","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"ABC","plain":"ABC","plainChilds":"","childs":[]},{"content":"CBC","plain":"CBC","plainChilds":"","childs":[]},{"content":"CCM","plain":"CCM","plainChilds":"","childs":[]},{"content":"CFB","plain":"CFB","plainChilds":"","childs":[]},{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"DFF","plain":"DFF","plainChilds":"","childs":[]},{"content":"EAX","plain":"EAX","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"OCB","plain":"OCB","plainChilds":"","childs":[]},{"content":"OFB","plain":"OFB","plainChilds":"","childs":[]},{"content":"SIV","plain":"SIV","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]},{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"DSA","plain":"DSA","plainChilds":"","childs":[]},{"content":"DSS","plain":"DSS","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"LDAP","plain":"LDAP","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PKCS","plain":"PKCS","plainChilds":"","childs":[]},{"content":"PKIX","plain":"PKIX","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"AKA","plain":"AKA","plainChilds":"","childs":[]},{"content":"CAVE","plain":"CAVE","plainChilds":"","childs":[]},{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"CSR","plain":"CSR","plainChilds":"","childs":[]},{"content":"CMS","plain":"CMS","plainChilds":"","childs":[]},{"content":"DTLS","plain":"DTLS","plainChilds":"","childs":[]},{"content":"DPD","plain":"DPD","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"IPsec","plain":"IPsec","plainChilds":"","childs":[]},{"content":"OTR","plain":"OTR","plainChilds":"","childs":[]},{"content":"OCSP","plain":"OCSP","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"PHE","plain":"PHE","plainChilds":"","childs":[]},{"content":"PGP","plain":"PGP","plainChilds":"","childs":[]},{"content":"S-HTTP","plain":"S-HTTP","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SRTP","plain":"SRTP","plainChilds":"","childs":[]},{"content":"SSH","plain":"SSH","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]},{"content":"TLS","plain":"TLS","plainChilds":"","childs":[]},{"content":"WPA","plain":"WPA","plainChilds":"","childs":[]},{"content":"X.509","plain":"X.509","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"There was an error collecting the CVE details\u0000","childs":{"0":[[{"content":"There was an error collecting the CVE details","plain":"There was an error collecting the CVE details\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Monocypher - https://monocypher.org/","descr":"An easy to use, easy to deploy crypto library","Description":{"plain":"Monocypher is an easy to use, easy to deploy, auditable crypto library written in portable C. It approaches the size of TweetNaCl and the speed of Libsodium.","childs":{"0":["Monocypher is an easy to use, easy to deploy, auditable crypto library written in portable C. It approaches the size of TweetNaCl and the speed of Libsodium."]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/LoupVaillant/Monocypher>\n    - Last repository change: 2019-10-14T09:16:59\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- CC-0\n- 2-clause BSD\n","childs":{"0":[[{"content":"CC-0","plain":"CC-0\n","plainChilds":"","childs":[]},{"content":"2-clause BSD","plain":"2-clause BSD\n","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- C99\n- C11\n- C++98\n- C++11\n- C++14\n- C++17\n","childs":{"0":[[{"content":"C99","plain":"C99\n","plainChilds":"","childs":[]},{"content":"C11","plain":"C11\n","plainChilds":"","childs":[]},{"content":"C++98","plain":"C++98\n","plainChilds":"","childs":[]},{"content":"C++11","plain":"C++11\n","plainChilds":"","childs":[]},{"content":"C++14","plain":"C++14\n","plainChilds":"","childs":[]},{"content":"C++17","plain":"C++17\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 260\n","childs":{"0":[[{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 260","plain":"Stars: 260","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"ChaCha","plain":"ChaCha","plainChilds":"","childs":[]},{"content":"Salsa","plain":"Salsa","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"BLAKE2","plain":"BLAKE2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"Poly1305","plain":"Poly1305","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"No Information","plain":"No Information","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}},{"tag":"Themis - https://www.cossacklabs.com/","descr":"Themis is an open-source high-level cryptographic services library for mobile and server platforms, which provides secure data exchange and storage.","Description":{"plain":"Themis provides four important cryptographic services:\n\n- Secure Message: a simple encrypted messaging solution for the widest scope of applications. Exchange the keys between the parties and you're good to go. Two pairs of the underlying crytosystems: ECC + ECDSA / RSA + PSS + PKCS#7.\n- Secure Session: session-oriented, forward secrecy datagram exchange solution with better security guarantees, but more demanding infrastructure. Secure Session can perfectly function as socket encryption, session security, or (with some additional infrastructure) as a high-level messaging primitive. ECDH key agreement, ECC & AES encryption.\n- Secure Cell: a multi-mode cryptographic container suitable for storing anything from encrypted files to database records and format-preserved strings. Secure Cell is built around AES in GCM (Token and Seal modes) and CTR (Context imprint mode).\n- Secure Comparator: a Zero-Knowledge based cryptographic protocol for authentication and comparing secrets.\n","childs":{"0":["Themis provides four important cryptographic services:",[{"content":"Secure Message: a simple encrypted messaging solution for the widest scope of applications. Exchange the keys between the parties and you're good to go. Two pairs of the underlying crytosystems: ECC + ECDSA / RSA + PSS + PKCS#7.","plain":"Secure Message: a simple encrypted messaging solution for the widest scope of applications. Exchange the keys between the parties and you're good to go. Two pairs of the underlying crytosystems: ECC + ECDSA / RSA + PSS + PKCS#7.\n","plainChilds":"","childs":[]},{"content":"Secure Session: session-oriented, forward secrecy datagram exchange solution with better security guarantees, but more demanding infrastructure. Secure Session can perfectly function as socket encryption, session security, or (with some additional infrastructure) as a high-level messaging primitive. ECDH key agreement, ECC & AES encryption.","plain":"Secure Session: session-oriented, forward secrecy datagram exchange solution with better security guarantees, but more demanding infrastructure. Secure Session can perfectly function as socket encryption, session security, or (with some additional infrastructure) as a high-level messaging primitive. ECDH key agreement, ECC & AES encryption.\n","plainChilds":"","childs":[]},{"content":"Secure Cell: a multi-mode cryptographic container suitable for storing anything from encrypted files to database records and format-preserved strings. Secure Cell is built around AES in GCM (Token and Seal modes) and CTR (Context imprint mode).","plain":"Secure Cell: a multi-mode cryptographic container suitable for storing anything from encrypted files to database records and format-preserved strings. Secure Cell is built around AES in GCM (Token and Seal modes) and CTR (Context imprint mode).\n","plainChilds":"","childs":[]},{"content":"Secure Comparator: a Zero-Knowledge based cryptographic protocol for authentication and comparing secrets.","plain":"Secure Comparator: a Zero-Knowledge based cryptographic protocol for authentication and comparing secrets.\n","plainChilds":"","childs":[]}]]}},"Repository":{"plain":"- Active\n","childs":{"0":[[{"content":"Active","plain":"Active\n","plainChilds":"    - <https://github.com/cossacklabs/themis>\n    - Last repository change: 2019-10-01T14:44:54\n    - Last checked: 2019-10-16T17:54:00","childs":[]}]]}},"License":{"plain":"- Apache-2.0\n","childs":{"0":[[{"content":"Apache-2.0","plain":"Apache-2.0\n","plainChilds":"","childs":[]}]]}},"Metadata":{"plain":"- Developed by Cossack Labs\n- The information is applicable to the latest commit in the repository, not a specific release!\n- Stars: 863\n","childs":{"0":[[{"content":"Developed by Cossack Labs","plain":"Developed by Cossack Labs\n","plainChilds":"","childs":[]},{"content":"The information is applicable to the latest commit in the repository, not a specific release!","plain":"The information is applicable to the latest commit in the repository, not a specific release!","plainChilds":"","childs":[]},{"content":"Stars: 863","plain":"Stars: 863","plainChilds":"","childs":[]}]]}},"Interface Languages":{"plain":"- Swift\n- Obj-C\n- Android/Java\n- C++\n- JavaScript\n- Python\n- Ruby\n- PHP\n- Go\n","childs":{"0":[[{"content":"Swift","plain":"Swift\n","plainChilds":"","childs":[]},{"content":"Obj-C","plain":"Obj-C\n","plainChilds":"","childs":[]},{"content":"Android/Java","plain":"Android/Java\n","plainChilds":"","childs":[]},{"content":"C++","plain":"C++\n","plainChilds":"","childs":[]},{"content":"JavaScript","plain":"JavaScript\n","plainChilds":"","childs":[]},{"content":"Python","plain":"Python\n","plainChilds":"","childs":[]},{"content":"Ruby","plain":"Ruby\n","plainChilds":"","childs":[]},{"content":"PHP","plain":"PHP\n","plainChilds":"","childs":[]},{"content":"Go","plain":"Go\n","plainChilds":"","childs":[]}]]}},"Development Languages":{"plain":"- C\n- C++\n- Python\n- Objective-C\n- Rust\n- Java\n- JavaScript\n- Go\n- Ruby\n- PHP\n- Swift\n","childs":{"0":[[{"content":"C","plain":"C","plainChilds":"","childs":[]},{"content":"C++","plain":"C++","plainChilds":"","childs":[]},{"content":"Python","plain":"Python","plainChilds":"","childs":[]},{"content":"Objective-C","plain":"Objective-C","plainChilds":"","childs":[]},{"content":"Rust","plain":"Rust","plainChilds":"","childs":[]},{"content":"Java","plain":"Java","plainChilds":"","childs":[]},{"content":"JavaScript","plain":"JavaScript","plainChilds":"","childs":[]},{"content":"Go","plain":"Go","plainChilds":"","childs":[]},{"content":"Ruby","plain":"Ruby","plainChilds":"","childs":[]},{"content":"PHP","plain":"PHP","plainChilds":"","childs":[]},{"content":"Swift","plain":"Swift","plainChilds":"","childs":[]}]]}},"Block Ciphers":{"plain":"","childs":{"0":[[{"content":"AES","plain":"AES","plainChilds":"","childs":[]},{"content":"AES-128","plain":"AES-128","plainChilds":"","childs":[]},{"content":"AES-192","plain":"AES-192","plainChilds":"","childs":[]},{"content":"AES-256","plain":"AES-256","plainChilds":"","childs":[]},{"content":"ARIA","plain":"ARIA","plainChilds":"","childs":[]},{"content":"CAST","plain":"CAST","plainChilds":"","childs":[]},{"content":"DEAL","plain":"DEAL","plainChilds":"","childs":[]},{"content":"IDEA","plain":"IDEA","plainChilds":"","childs":[]},{"content":"M6","plain":"M6","plainChilds":"","childs":[]},{"content":"M8","plain":"M8","plainChilds":"","childs":[]},{"content":"MAGENTA","plain":"MAGENTA","plainChilds":"","childs":[]},{"content":"NDS","plain":"NDS","plainChilds":"","childs":[]},{"content":"PRESENT","plain":"PRESENT","plainChilds":"","childs":[]},{"content":"SEED","plain":"SEED","plainChilds":"","childs":[]}]]}},"Stream Ciphers":{"plain":"","childs":{"0":[[{"content":"Rabbit","plain":"Rabbit","plainChilds":"","childs":[]},{"content":"SEAL","plain":"SEAL","plainChilds":"","childs":[]}]]}},"Hash Functions":{"plain":"","childs":{"0":[[{"content":"MD2","plain":"MD2","plainChilds":"","childs":[]},{"content":"MD5","plain":"MD5","plainChilds":"","childs":[]},{"content":"MD6","plain":"MD6","plainChilds":"","childs":[]},{"content":"PBKDF2","plain":"PBKDF2","plainChilds":"","childs":[]},{"content":"SHA","plain":"SHA","plainChilds":"","childs":[]},{"content":"SHA-1","plain":"SHA-1","plainChilds":"","childs":[]},{"content":"SHA-2","plain":"SHA-2","plainChilds":"","childs":[]},{"content":"SHA-3","plain":"SHA-3","plainChilds":"","childs":[]},{"content":"SHA-256","plain":"SHA-256","plainChilds":"","childs":[]},{"content":"SHA-512","plain":"SHA-512","plainChilds":"","childs":[]}]]}},"Encryption Modes":{"plain":"","childs":{"0":[[{"content":"CTR","plain":"CTR","plainChilds":"","childs":[]},{"content":"DFF","plain":"DFF","plainChilds":"","childs":[]},{"content":"ECB","plain":"ECB","plainChilds":"","childs":[]},{"content":"FFX","plain":"FFX","plainChilds":"","childs":[]},{"content":"GCM","plain":"GCM","plainChilds":"","childs":[]},{"content":"IOC","plain":"IOC","plainChilds":"","childs":[]},{"content":"XBC","plain":"XBC","plainChilds":"","childs":[]}]]}},"Message Authentication Codes":{"plain":"","childs":{"0":[[{"content":"HMAC","plain":"HMAC","plainChilds":"","childs":[]}]]}},"Public Key Cryptography":{"plain":"","childs":{"0":[[{"content":"DH","plain":"DH","plainChilds":"","childs":[]},{"content":"ECDH","plain":"ECDH","plainChilds":"","childs":[]},{"content":"ECDSA","plain":"ECDSA","plainChilds":"","childs":[]},{"content":"RSA","plain":"RSA","plainChilds":"","childs":[]}]]}},"Public Key Infrastructure":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"RDBMS","plain":"RDBMS","plainChilds":"","childs":[]},{"content":"SET","plain":"SET","plainChilds":"","childs":[]}]]}},"Protocols":{"plain":"","childs":{"0":[[{"content":"CMP","plain":"CMP","plainChilds":"","childs":[]},{"content":"DCII","plain":"DCII","plainChilds":"","childs":[]},{"content":"EST","plain":"EST","plainChilds":"","childs":[]},{"content":"GPG","plain":"GPG","plainChilds":"","childs":[]},{"content":"HTTPS","plain":"HTTPS","plainChilds":"","childs":[]},{"content":"IKE","plain":"IKE","plainChilds":"","childs":[]},{"content":"PE","plain":"PE","plainChilds":"","childs":[]},{"content":"PEM","plain":"PEM","plainChilds":"","childs":[]},{"content":"SEND","plain":"SEND","plainChilds":"","childs":[]},{"content":"SSL","plain":"SSL","plainChilds":"","childs":[]}]]}},"CVE Details":{"plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","childs":{"0":[[{"content":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.","plain":"No CVE Vendor or CVE Product to search for CVE Details specified. You can find the info about this library in [this directory](https://github.com/cryptocatalog/ultimate-crypto-comparison/tree/master/data). You can [create a pull-request](https://github.com/cryptocatalog/ultimate-crypto-comparison/pulls) or open a [new issue](https://github.com/cryptocatalog/ultimate-crypto-comparison/issues) to add this information.\u0000","plainChilds":"","childs":[]}]]}}}]